"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInput = getInput;
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

var _form = require("./form.validation");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var FormAction;

(function (FormAction) {
  FormAction["INPUT_CHANGE"] = "INPUT_CHANGE";
  FormAction["INPUT_TOUCH"] = "INPUT_TOUCH";
  FormAction["SET_FORM"] = "SET_FORM";
})(FormAction || (FormAction = {}));

/**
 * Get an object of type FormEntryState by just defining the input type, initial value and options.
 *
 * @param initialValue - initial value of the input entry.
 * @param options      - (optional) options for initial input state and validation
 * @returns Object of type FormEntryState
 */
function getInput(initialValue, options) {
  var parsedOptions = {
    isValid: false,
    isTouched: false,
    validators: [],
    connectedFields: (options === null || options === void 0 ? void 0 : options.connectFields) || []
  };

  if (typeof options !== 'undefined') {
    var keys = Object.keys(options);
    parsedOptions.isTouched = !!options.isTouched;
    parsedOptions.isValid = !!options.isValid;
    keys.forEach(function (key) {
      if (!['isValid', 'isTouched', 'connectedFields'].includes(key)) {
        parsedOptions.validators.push((0, _form.getValidator)(key, options[key]));
      }
    });
  }

  return _objectSpread(_objectSpread({}, parsedOptions), {}, {
    value: initialValue
  });
}
/**
 * Handle all connected fields tied to a certain input. This is useful for the following reason:
 *
 * If we have input A and input B and input B is dependent upon input A. Then we'd like to be able to
 * run the validation for input B each time the value of input A changes.
 *
 * @param state   - current FormState where the connected inputs can be found
 * @param targetId - Id of the owning input (input A in the example above)
 * @returns An object with entry keys and their updated object of type FormEntryState
 */


var handleConnectedFields = function handleConnectedFields(state, targetId) {
  try {
    var newInputState = _objectSpread({}, state.inputs); // find connected fields from the targetId


    newInputState[targetId].connectedFields.forEach(function (connectedFieldId) {
      // if the connected field exists
      if (typeof newInputState[connectedFieldId] !== 'undefined') {
        // then validate it given the specified state
        newInputState[connectedFieldId] = _objectSpread(_objectSpread({}, newInputState[connectedFieldId]), {}, {
          isValid: (0, _form.validate)(newInputState[connectedFieldId].value, newInputState[connectedFieldId].validators, state)
        });
      }
    });
    return newInputState;
  } catch (err) {
    process.env.NODE_ENV !== 'production' && console.error(err);
    return state.inputs;
  }
};
/**
 * Handle changes to FormState given an action associated with a payload.
 *
 * @param state Object with current FormState
 * @param action FormAction and FormPayload to handle
 * @returns Object with the updated FormState
 */


function formReducer(state, action) {
  var pl = action.payload;

  switch (action.type) {
    case FormAction.INPUT_CHANGE:
      // copy the current state, update the entry with the specified payload Id and validate it.
      var newState = _objectSpread(_objectSpread({}, state), {}, {
        inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
          value: pl.value,
          isValid: (0, _form.validate)(pl.value, state.inputs[pl.id].validators, state)
        })))
      }); // copy the inputs and validate connected fields given the now updated state.


      newState.inputs = _objectSpread(_objectSpread({}, newState.inputs), handleConnectedFields(_objectSpread({}, newState), pl.id)); // validate the entire form, if a single key fails, the whole form becomes invalid.

      var isValid = true;

      for (var _key in newState.inputs) {
        isValid = isValid && newState.inputs[_key].isValid;
      } // return the updated FormState


      return _objectSpread(_objectSpread({}, newState), {}, {
        inputs: _objectSpread({}, newState.inputs),
        isValid: isValid
      });

    case FormAction.INPUT_TOUCH:
      return _objectSpread(_objectSpread({}, state), {}, {
        inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
          isTouched: true
        })))
      });

    case FormAction.SET_FORM:
      if (typeof pl.state !== 'undefined') {
        return _objectSpread({}, pl.state);
      } else {
        return state;
      }

    default:
      return state;
  }
}
/**
 * React hook for managing the state of a form and its associated inputs.
 *
 * @param initialState - Object with initial FormState

 * @returns Object of UseForm type with specified properties and types.
 */


function useForm(initialState) {
  var _useReducer = (0, _react.useReducer)(formReducer, _objectSpread({}, initialState)),
      _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
      formState = _useReducer2[0],
      dispatch = _useReducer2[1];

  var setFormState = (0, _react.useCallback)(function (state) {
    dispatch({
      type: FormAction.SET_FORM,
      payload: {
        state: state,
        value: '',
        id: ''
      }
    });
  }, []);
  var onTouchHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_TOUCH,
      payload: {
        id: event.target.id,
        value: ''
      }
    });
  }, []);
  var onChangeHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_CHANGE,
      payload: {
        id: event.target.id,
        value: event.target.value
      }
    });
  }, []);
  return {
    formState: formState,
    onChangeHandler: onChangeHandler,
    onTouchHandler: onTouchHandler,
    setFormState: setFormState
  };
}

var _default = useForm;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mb3JtLmhvb2sudHMiXSwibmFtZXMiOlsiRm9ybUFjdGlvbiIsImdldElucHV0IiwiaW5pdGlhbFZhbHVlIiwib3B0aW9ucyIsInBhcnNlZE9wdGlvbnMiLCJpc1ZhbGlkIiwiaXNUb3VjaGVkIiwidmFsaWRhdG9ycyIsImNvbm5lY3RlZEZpZWxkcyIsImNvbm5lY3RGaWVsZHMiLCJrZXlzIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicHVzaCIsInZhbHVlIiwiaGFuZGxlQ29ubmVjdGVkRmllbGRzIiwic3RhdGUiLCJ0YXJnZXRJZCIsIm5ld0lucHV0U3RhdGUiLCJpbnB1dHMiLCJjb25uZWN0ZWRGaWVsZElkIiwiZXJyIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwiZm9ybVJlZHVjZXIiLCJhY3Rpb24iLCJwbCIsInBheWxvYWQiLCJ0eXBlIiwiSU5QVVRfQ0hBTkdFIiwibmV3U3RhdGUiLCJpZCIsIklOUFVUX1RPVUNIIiwiU0VUX0ZPUk0iLCJ1c2VGb3JtIiwiaW5pdGlhbFN0YXRlIiwiZm9ybVN0YXRlIiwiZGlzcGF0Y2giLCJzZXRGb3JtU3RhdGUiLCJvblRvdWNoSGFuZGxlciIsImV2ZW50IiwidGFyZ2V0Iiwib25DaGFuZ2VIYW5kbGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBOzs7Ozs7SUFFS0EsVTs7V0FBQUEsVTtBQUFBQSxFQUFBQSxVO0FBQUFBLEVBQUFBLFU7QUFBQUEsRUFBQUEsVTtHQUFBQSxVLEtBQUFBLFU7O0FBa0VMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0MsUUFBVCxDQUNIQyxZQURHLEVBRUhDLE9BRkcsRUFHYztBQUNqQixNQUFNQyxhQUErQyxHQUFHO0FBQ3BEQyxJQUFBQSxPQUFPLEVBQUUsS0FEMkM7QUFFcERDLElBQUFBLFNBQVMsRUFBRSxLQUZ5QztBQUdwREMsSUFBQUEsVUFBVSxF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QVVBLFNBQU87QUFBRXlCLElBQUFBLFNBQVMsRUFBVEEsU0FBRjtBQUFhTSxJQUFBQSxlQUFlLEVBQWZBLGVBQWI7QUFBOEJILElBQUFBLGNBQWMsRUFBZEEsY0FBOUI7QUFBOENELElBQUFBLFlBQVksRUFBWkE7QUFBOUMsR0FBUDtBQUNIOztlQUVjSixPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVkdWNlciwgdXNlQ2FsbGJhY2ssIFJlZHVjZXIgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFZhbGlkYXRvciwgVmFsaWRhdGlvblR5cGUsIEN1c3RvbVZhbGlkYXRpb25SdWxlLCBnZXRWYWxpZGF0b3IsIHZhbGlkYXRlIH0gZnJvbSAnLi9mb3JtLnZhbGlkYXRpb24nO1xuXG5lbnVtIEZvcm1BY3Rpb24ge1xuICAgIElOUFVUX0NIQU5HRSA9ICdJTlBVVF9DSEFOR0UnLFxuICAgIElOUFVUX1RPVUNIID0gJ0lOUFVUX1RPVUNIJyxcbiAgICBTRVRfRk9STSA9ICdTRVRfRk9STSdcbn1cblxuaW50ZXJmYWNlIEZvcm1QYXlsb2FkIGV4dGVuZHMgUGljazxGb3JtRW50cnlTdGF0ZTxhbnk+LCAndmFsdWUnPiB7XG4gICAgcmVhZG9ubHkgaWQ6IHN0cmluZztcbiAgICByZWFkb25seSBzdGF0ZT86IEZvcm1TdGF0ZTxhbnk+O1xufVxuXG50eXBlIEZvcm1FbGVtZW50Q29uc3RyYWludCA9IEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50IHwgSFRNTFNlbGVjdEVsZW1lbnQgfCBIVE1MT3B0aW9uRWxlbWVudDtcblxudHlwZSBSZWR1Y2VyQWN0aW9uID0geyB0eXBlOiBGb3JtQWN0aW9uOyBwYXlsb2FkOiBGb3JtUGF5bG9hZCB9O1xuXG50eXBlIEdldElucHV0T3B0aW9uczxUIGV4dGVuZHMgRm9ybVZhbHVlVHlwZSwgUyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQgPSBhbnk+ID0ge1xuICAgIFtrZXk6IHN0cmluZ106IFQgfCBudW1iZXIgfCBib29sZWFuIHwgQ3VzdG9tVmFsaWRhdGlvblJ1bGU8VCwgUz4gfCBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcbiAgICBtaW5MZW5ndGg/OiBudW1iZXI7XG4gICAgbWF4TGVuZ3RoPzogbnVtYmVyO1xuICAgIG1pblZhbHVlPzogbnVtYmVyO1xuICAgIG1heFZhbHVlPzogbnVtYmVyO1xuICAgIG1pblVwcGVyY2FzZUNoYXJhY3RlcnM/OiBudW1iZXI7XG4gICAgbWF4VXBwZXJjYXNlQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtaW5OdW1lcmljYWxTeW1ib2xzPzogbnVtYmVyO1xuICAgIG1heE51bWVyaWNhbFN5bWJvbHM/OiBudW1iZXI7XG4gICAgaXNSZXF1aXJlZD86IGJvb2xlYW47XG4gICAgaXNWYWxpZD86IGJvb2xlYW47XG4gICAgaXNUb3VjaGVkPzogYm9vbGVhbjtcbiAgICBjdXN0b21SdWxlPzogQ3VzdG9tVmFsaWRhdGlvblJ1bGU8VCwgUz47XG4gICAgY29ubmVjdEZpZWxkcz86IHN0cmluZ1tdO1xufTtcblxuLyogVGhpcyBpcyB0aGUgYmFzZSBmb3IgYW55IGlucHV0IGVudHJ5IGluIGEgJ2Zvcm1TdGF0ZScuIEluIG90aGVyIHdvcmRzXG4gICBhbGwgaW5wdXQgZW50cmllcyB3aWxsIGhhdmUgdGhlc2UgcHJvcGVydGllcyBhdmFpbGFibGUuICovXG50eXBlIEZvcm1FbnRyeVN0YXRlPFQgZXh0ZW5kcyBGb3JtVmFsdWVUeXBlPiA9IHtcbiAgICB2YWx1ZTogVDtcbiAgICBpc1ZhbGlkOiBib29sZWFuO1xuICAgIGlzVG91Y2hlZDogYm9vbGVhbjtcbiAgICByZWFkb25seSB2YWxpZGF0b3JzOiBWYWxpZGF0b3JbXTtcbiAgICByZWFkb25seSBjb25uZWN0ZWRGaWVsZHM6IHN0cmluZ1tdO1xufTtcblxuLyogVGhlIHR5cGUgb2Ygb2JqZWN0IHJldHVybmVkIGJ5IHVzZUZvcm0gd2hlbiBpbml0aWFsaXplZC4gKi9cbnR5cGUgVXNlRm9ybTxTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4gPSB7XG4gICAgZm9ybVN0YXRlOiBGb3JtU3RhdGU8Uz47XG4gICAgb25Ub3VjaEhhbmRsZXI6IFJlYWN0LkZvY3VzRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD47XG4gICAgb25DaGFuZ2VIYW5kbGVyOiBSZWFjdC5DaGFuZ2VFdmVudEhhbmRsZXI8Rm9ybUVsZW1lbnRDb25zdHJhaW50PjtcbiAgICBzZXRGb3JtU3RhdGU6IChzdGF0ZTogRm9ybVN0YXRlPFM+KSA9PiB2b2lkO1xufTtcblxuLy8gU3VwcG9ydGVkIGlucHV0IHZhbGVzLiBDYW4gYmUgZXh0ZW5kZWQgaWYgbmVlZCBiZS5cbmV4cG9ydCB0eXBlIEZvcm1WYWx1ZVR5cGUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRmlsZTtcblxuLyogUHJvcGVydHkgbmFtZXMgYW5kIHR5cGVzIG9mIGlucHV0cywgZm9yIGV4YW1wbGU6XG4gICB7IHBhc3N3b3JkOiBzdHJpbmc7IGFnZTogbnVtYmVyOyBpc0hhcHB5OiBib29sZWFuOyB9ICovXG5leHBvcnQgdHlwZSBGb3JtRW50cnlDb25zdHJhaW50ID0geyBba2V5OiBzdHJpbmddOiBGb3JtVmFsdWVUeXBlIH07XG5cbi8qIFRoaXMgaXMgdGhlIGJhc2UgZm9yIHRoZSBmb3JtIHN0YXRlIGFuZCB0aGUgdHlwZSBvZiBvYmplY3QgdGhhdCBpcyByZXR1cm5lZFxuICAgYnkgdXNlRm9ybSgpLmZvcm1TdGF0ZS4gVGh1cywgJ2Zvcm1TdGF0ZScgd2lsbCBhbHdheXMgaGF2ZSBwcm9wZXJ0aWVzXG4gICAnaW5wdXRzJyBhbmQgJ2lzVmFsaWQnIGF2YWlsYWJsZSB3aGlsZSB0aGUgaW5wdXRzIHByb3BlcnR5LCBpZiBub24tZW1wdHksIFxuICAgd2lsbCBoYXZlIGtleXMgdGhhdCB5aWVsZHMgYW4gb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGUgKi9cbmV4cG9ydCB0eXBlIEZvcm1TdGF0ZTxUIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4gPSB7XG4gICAgaW5wdXRzOiB7IFtLIGluIGtleW9mIFRdOiBGb3JtRW50cnlTdGF0ZTxUW0tdPiB9O1xuICAgIGlzVmFsaWQ6IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgb2YgdHlwZSBGb3JtRW50cnlTdGF0ZSBieSBqdXN0IGRlZmluaW5nIHRoZSBpbnB1dCB0eXBlLCBpbml0aWFsIHZhbHVlIGFuZCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsVmFsdWUgLSBpbml0aWFsIHZhbHVlIG9mIHRoZSBpbnB1dCBlbnRyeS5cbiAqIEBwYXJhbSBvcHRpb25zICAgICAgLSAob3B0aW9uYWwpIG9wdGlvbnMgZm9yIGluaXRpYWwgaW5wdXQgc3RhdGUgYW5kIHZhbGlkYXRpb25cbiAqIEByZXR1cm5zIE9iamVjdCBvZiB0eXBlIEZvcm1FbnRyeVN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnB1dDxUIGV4dGVuZHMgRm9ybVZhbHVlVHlwZSwgUyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQgPSBhbnk+KFxuICAgIGluaXRpYWxWYWx1ZTogVCxcbiAgICBvcHRpb25zPzogR2V0SW5wdXRPcHRpb25zPFQsIFM+XG4pOiBGb3JtRW50cnlTdGF0ZTxUPiB7XG4gICAgY29uc3QgcGFyc2VkT3B0aW9uczogT21pdDxGb3JtRW50cnlTdGF0ZTxUPiwgJ3ZhbHVlJz4gPSB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBpc1RvdWNoZWQ6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0b3JzOiBbXSxcbiAgICAgICAgY29ubmVjdGVkRmllbGRzOiBvcHRpb25zPy5jb25uZWN0RmllbGRzIHx8IFtdXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICAgICAgcGFyc2VkT3B0aW9ucy5pc1RvdWNoZWQgPSAhIW9wdGlvbnMuaXNUb3VjaGVkO1xuICAgICAgICBwYXJzZWRPcHRpb25zLmlzVmFsaWQgPSAhIW9wdGlvbnMuaXNWYWxpZDtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghWydpc1ZhbGlkJywgJ2lzVG91Y2hlZCcsICdjb25uZWN0ZWRGaWVsZHMnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkT3B0aW9ucy52YWxpZGF0b3JzLnB1c2goZ2V0VmFsaWRhdG9yKGtleSBhcyBWYWxpZGF0aW9uVHlwZSwgb3B0aW9uc1trZXldIGFzIFQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnBhcnNlZE9wdGlvbnMsXG4gICAgICAgIHZhbHVlOiBpbml0aWFsVmFsdWVcbiAgICB9O1xufVxuXG4vKipcbiAqIEhhbmRsZSBhbGwgY29ubmVjdGVkIGZpZWxkcyB0aWVkIHRvIGEgY2VydGFpbiBpbnB1dC4gVGhpcyBpcyB1c2VmdWwgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uOlxuICpcbiAqIElmIHdlIGhhdmUgaW5wdXQgQSBhbmQgaW5wdXQgQiBhbmQgaW5wdXQgQiBpcyBkZXBlbmRlbnQgdXBvbiBpbnB1dCBBLiBUaGVuIHdlJ2QgbGlrZSB0byBiZSBhYmxlIHRvXG4gKiBydW4gdGhlIHZhbGlkYXRpb24gZm9yIGlucHV0IEIgZWFjaCB0aW1lIHRoZSB2YWx1ZSBvZiBpbnB1dCBBIGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHN0YXRlICAgLSBjdXJyZW50IEZvcm1TdGF0ZSB3aGVyZSB0aGUgY29ubmVjdGVkIGlucHV0cyBjYW4gYmUgZm91bmRcbiAqIEBwYXJhbSB0YXJnZXRJZCAtIElkIG9mIHRoZSBvd25pbmcgaW5wdXQgKGlucHV0IEEgaW4gdGhlIGV4YW1wbGUgYWJvdmUpXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBlbnRyeSBrZXlzIGFuZCB0aGVpciB1cGRhdGVkIG9iamVjdCBvZiB0eXBlIEZvcm1FbnRyeVN0YXRlXG4gKi9cbmNvbnN0IGhhbmRsZUNvbm5lY3RlZEZpZWxkcyA9IChzdGF0ZTogRm9ybVN0YXRlPGFueT4sIHRhcmdldElkOiBzdHJpbmcpOiB7IFtrZXk6IHN0cmluZ106IEZvcm1FbnRyeVN0YXRlPGFueT4gfSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3SW5wdXRTdGF0ZSA9IHsgLi4uc3RhdGUuaW5wdXRzIH07XG4gICAgICAgIC8vIGZpbmQgY29ubmVjdGVkIGZpZWxkcyBmcm9tIHRoZSB0YXJnZXRJZFxuICAgICAgICBuZXdJbnB1dFN0YXRlW3RhcmdldElkXS5jb25uZWN0ZWRGaWVsZHMuZm9yRWFjaCgoY29ubmVjdGVkRmllbGRJZCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3RlZCBmaWVsZCBleGlzdHNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHZhbGlkYXRlIGl0IGdpdmVuIHRoZSBzcGVjaWZpZWQgc3RhdGVcbiAgICAgICAgICAgICAgICBuZXdJbnB1dFN0YXRlW2Nvbm5lY3RlZEZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5uZXdJbnB1dFN0YXRlW2Nvbm5lY3RlZEZpZWxkSWRdLFxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiB2YWxpZGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnB1dFN0YXRlW2Nvbm5lY3RlZEZpZWxkSWRdLnZhbGlkYXRvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdJbnB1dFN0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmlucHV0cztcbiAgICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBjaGFuZ2VzIHRvIEZvcm1TdGF0ZSBnaXZlbiBhbiBhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIGEgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgT2JqZWN0IHdpdGggY3VycmVudCBGb3JtU3RhdGVcbiAqIEBwYXJhbSBhY3Rpb24gRm9ybUFjdGlvbiBhbmQgRm9ybVBheWxvYWQgdG8gaGFuZGxlXG4gKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgdXBkYXRlZCBGb3JtU3RhdGVcbiAqL1xuZnVuY3Rpb24gZm9ybVJlZHVjZXI8UyBleHRlbmRzIEZvcm1TdGF0ZTxhbnk+PihzdGF0ZTogUywgYWN0aW9uOiBSZWR1Y2VyQWN0aW9uKTogUyB7XG4gICAgY29uc3QgcGwgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgRm9ybUFjdGlvbi5JTlBVVF9DSEFOR0U6XG4gICAgICAgICAgICAvLyBjb3B5IHRoZSBjdXJyZW50IHN0YXRlLCB1cGRhdGUgdGhlIGVudHJ5IHdpdGggdGhlIHNwZWNpZmllZCBwYXlsb2FkIElkIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlOiBTID0ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbnB1dHMsXG4gICAgICAgICAgICAgICAgICAgIFtwbC5pZF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmlucHV0c1twbC5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGwudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiB2YWxpZGF0ZShwbC52YWx1ZSwgc3RhdGUuaW5wdXRzW3BsLmlkXS52YWxpZGF0b3JzLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjb3B5IHRoZSBpbnB1dHMgYW5kIHZhbGlkYXRlIGNvbm5lY3RlZCBmaWVsZHMgZ2l2ZW4gdGhlIG5vdyB1cGRhdGVkIHN0YXRlLlxuICAgICAgICAgICAgbmV3U3RhdGUuaW5wdXRzID0ge1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLmlucHV0cyxcbiAgICAgICAgICAgICAgICAuLi5oYW5kbGVDb25uZWN0ZWRGaWVsZHMoeyAuLi5uZXdTdGF0ZSB9LCBwbC5pZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSB0aGUgZW50aXJlIGZvcm0sIGlmIGEgc2luZ2xlIGtleSBmYWlscywgdGhlIHdob2xlIGZvcm0gYmVjb21lcyBpbnZhbGlkLlxuICAgICAgICAgICAgbGV0IGlzVmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3U3RhdGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IGlzVmFsaWQgJiYgbmV3U3RhdGUuaW5wdXRzW2tleV0uaXNWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgdXBkYXRlZCBGb3JtU3RhdGVcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLmlucHV0c1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNWYWxpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBGb3JtQWN0aW9uLklOUFVUX1RPVUNIOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICBbcGwuaWRdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbnB1dHNbcGwuaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIEZvcm1BY3Rpb24uU0VUX0ZPUk06XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsLnN0YXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLihwbC5zdGF0ZSBhcyBTKSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlYWN0IGhvb2sgZm9yIG1hbmFnaW5nIHRoZSBzdGF0ZSBvZiBhIGZvcm0gYW5kIGl0cyBhc3NvY2lhdGVkIGlucHV0cy5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIC0gT2JqZWN0IHdpdGggaW5pdGlhbCBGb3JtU3RhdGVcblxuICogQHJldHVybnMgT2JqZWN0IG9mIFVzZUZvcm0gdHlwZSB3aXRoIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGFuZCB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gdXNlRm9ybTxTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4oaW5pdGlhbFN0YXRlOiBGb3JtU3RhdGU8Uz4pOiBVc2VGb3JtPFM+IHtcbiAgICBjb25zdCBbZm9ybVN0YXRlLCBkaXNwYXRjaF0gPSB1c2VSZWR1Y2VyPFJlZHVjZXI8Rm9ybVN0YXRlPFM+LCBSZWR1Y2VyQWN0aW9uPj4oZm9ybVJlZHVjZXIsIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0YXRlXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZXRGb3JtU3RhdGUgPSB1c2VDYWxsYmFjaygoc3RhdGU6IEZvcm1TdGF0ZTxTPik6IHZvaWQgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IEZvcm1BY3Rpb24uU0VUX0ZPUk0sIHBheWxvYWQ6IHsgc3RhdGUsIHZhbHVlOiAnJywgaWQ6ICcnIH0gfSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgb25Ub3VjaEhhbmRsZXI6IFJlYWN0LkZvY3VzRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD4gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiBGb3JtQWN0aW9uLklOUFVUX1RPVUNILCBwYXlsb2FkOiB7IGlkOiBldmVudC50YXJnZXQuaWQsIHZhbHVlOiAnJyB9IH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uQ2hhbmdlSGFuZGxlcjogUmVhY3QuQ2hhbmdlRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD4gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogRm9ybUFjdGlvbi5JTlBVVF9DSEFOR0UsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LnRhcmdldC5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IGZvcm1TdGF0ZSwgb25DaGFuZ2VIYW5kbGVyLCBvblRvdWNoSGFuZGxlciwgc2V0Rm9ybVN0YXRlIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUZvcm07XG4iXX0=