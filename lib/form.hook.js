"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInput = getInput;
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

var _form = require("./form.validation");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var FormAction;

(function (FormAction) {
  FormAction["INPUT_CHANGE"] = "INPUT_CHANGE";
  FormAction["INPUT_TOUCH"] = "INPUT_TOUCH";
  FormAction["SET_FORM"] = "SET_FORM";
})(FormAction || (FormAction = {}));

/**
 * Get an object of type FormEntryState by just defining the input type, initial value and options.
 *
 * @param initialValue - initial value of the input entry.
 * @param options      - (optional) options for initial input state and validation
 * @returns Object of type FormEntryState
 */
function getInput(initialValue, options) {
  var parsedOptions = {
    isValid: false,
    isTouched: false,
    validators: [],
    connectedFields: (options === null || options === void 0 ? void 0 : options.connectFields) || []
  };

  if (typeof options !== 'undefined') {
    var keys = Object.keys(options);
    parsedOptions.isTouched = !!options.isTouched;
    parsedOptions.isValid = !!options.isValid;
    keys.forEach(function (key) {
      if (!['isValid', 'isTouched', 'connectedFields'].includes(key)) {
        parsedOptions.validators.push((0, _form.getValidator)(key, options[key]));
      }
    });
  }

  return _objectSpread(_objectSpread({}, parsedOptions), {}, {
    value: initialValue
  });
}
/**
 * Handle all connected fields tied to a certain input. This is useful for the following reason:
 *
 * If we have input A and input B and input B is dependent upon input A. Then we'd like to be able to
 * run the validation for input B each time the value of input A changes.
 *
 * @param state   - current FormState where the connected inputs can be found
 * @param targetId - Id of the owning input (input A in the example above)
 * @returns An object with entry keys and their updated object of type FormEntryState
 */


var handleConnectedFields = function handleConnectedFields(state, targetId) {
  try {
    var newInputState = _objectSpread({}, state.inputs); // find connected fields from the targetId


    newInputState[targetId].connectedFields.forEach(function (connectedFieldId) {
      // if the connected field exists
      if (typeof newInputState[connectedFieldId] !== 'undefined') {
        // then validate it given the specified state
        newInputState[connectedFieldId] = _objectSpread(_objectSpread({}, newInputState[connectedFieldId]), {}, {
          isValid: (0, _form.validate)(newInputState[connectedFieldId].value, newInputState[connectedFieldId].validators, state)
        });
      }
    });
    return newInputState;
  } catch (err) {
    process.env.NODE_ENV !== 'production' && console.error(err);
    return state.inputs;
  }
};
/**
 * Handle changes to FormState given an action associated with a payload.
 *
 * @param state Object with current FormState
 * @param action FormAction and FormPayload to handle
 * @returns Object with the updated FormState
 */


function formReducer(state, action) {
  var pl = action.payload;

  switch (action.type) {
    case FormAction.INPUT_CHANGE:
      // copy the current state, update the entry with the specified payload Id and validate it.
      var newState = _objectSpread(_objectSpread({}, state), {}, {
        inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
          value: pl.value,
          isValid: (0, _form.validate)(pl.value, state.inputs[pl.id].validators, state)
        })))
      }); // copy the inputs and validate connected fields given the now updated state.


      newState.inputs = _objectSpread(_objectSpread({}, newState.inputs), handleConnectedFields(newState, pl.id)); // return the updated FormState

      return _objectSpread(_objectSpread({}, newState), {}, {
        inputs: _objectSpread({}, newState.inputs),
        isValid: (0, _form.validateState)(newState)
      });

    case FormAction.INPUT_TOUCH:
      return _objectSpread(_objectSpread({}, state), {}, {
        inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
          isTouched: true
        })))
      });

    case FormAction.SET_FORM:
      if (typeof pl.state !== 'undefined') {
        return _objectSpread({}, pl.state);
      } else {
        return state;
      }

    default:
      return state;
  }
}

function getState(initialState) {
  var state;

  if (Object.keys(initialState).length === 2 && typeof initialState.inputs !== 'undefined' && typeof initialState.isValid !== 'undefined') {
    state = _objectSpread({}, initialState);
  } else {
    state = {
      inputs: _objectSpread({}, initialState),
      isValid: false
    };
    state.isValid = (0, _form.validateState)(state);
  }

  return state;
}
/**
 * React hook for managing the state of a form and its associated inputs.
 *
 * @param initialState - Object with initial FormState or initial Inputs

 * @returns Object of UseForm type with specified properties and types.
 */


function useForm(initialState) {
  var _useReducer = (0, _react.useReducer)(formReducer, _objectSpread({}, getState(initialState))),
      _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
      formState = _useReducer2[0],
      dispatch = _useReducer2[1];

  var setFormState = (0, _react.useCallback)(function (state) {
    dispatch({
      type: FormAction.SET_FORM,
      payload: {
        state: _objectSpread({}, getState(state)),
        value: '',
        id: ''
      }
    });
  }, []);
  var onTouchHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_TOUCH,
      payload: {
        id: event.target.id,
        value: ''
      }
    });
  }, []);
  var onChangeHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_CHANGE,
      payload: {
        id: event.target.id,
        value: event.target.value
      }
    });
  }, []);
  return {
    formState: formState,
    onChangeHandler: onChangeHandler,
    onTouchHandler: onTouchHandler,
    setFormState: setFormState
  };
}

var _default = useForm;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mb3JtLmhvb2sudHMiXSwibmFtZXMiOlsiRm9ybUFjdGlvbiIsImdldElucHV0IiwiaW5pdGlhbFZhbHVlIiwib3B0aW9ucyIsInBhcnNlZE9wdGlvbnMiLCJpc1ZhbGlkIiwiaXNUb3VjaGVkIiwidmFsaWRhdG9ycyIsImNvbm5lY3RlZEZpZWxkcyIsImNvbm5lY3RGaWVsZHMiLCJrZXlzIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicHVzaCIsInZhbHVlIiwiaGFuZGxlQ29ubmVjdGVkRmllbGRzIiwic3RhdGUiLCJ0YXJnZXRJZCIsIm5ld0lucHV0U3RhdGUiLCJpbnB1dHMiLCJjb25uZWN0ZWRGaWVsZElkIiwiZXJyIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwiZm9ybVJlZHVjZXIiLCJhY3Rpb24iLCJwbCIsInBheWxvYWQiLCJ0eXBlIiwiSU5QVVRfQ0hBTkdFIiwibmV3U3RhdGUiLCJpZCIsIklOUFVUX1RPVUNIIiwiU0VUX0ZPUk0iLCJnZXRTdGF0ZSIsImluaXRpYWxTdGF0ZSIsImxlbmd0aCIsInVzZUZvcm0iLCJmb3JtU3RhdGUiLCJkaXNwYXRjaCIsInNldEZvcm1TdGF0ZSIsIm9uVG91Y2hIYW5kbGVyIiwiZXZlbnQiLCJ0YXJnZXQiLCJvbkNoYW5nZUhhbmRsZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7Ozs7OztJQVNLQSxVOztXQUFBQSxVO0FBQUFBLEVBQUFBLFU7QUFBQUEsRUFBQUEsVTtBQUFBQSxFQUFBQSxVO0dBQUFBLFUsS0FBQUEsVTs7QUFvR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQyxRQUFULENBQ0hDLFlBREcsRUFFSEMsT0FGRyxFQUdjO0FBQ2pCLE1BQU1DLGFBQStDLEdBQUc7QUFDcERDLElBQUFBLE9BQU8sRUFBRSxLQUQyQztBQUVwREMsSUFBQUEsU0FBUyxFQUFFLEtBRnlD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QUFELENBQVI7QUFDSCxHQUZzRSxFQUVwRSxFQUZvRSxDQUF2RTtBQUlBLE1BQU1pQyxlQUFnRSxHQUFHLHdCQUFZLFVBQUNGLEtBQUQsRUFBVztBQUM1RkgsSUFBQUEsUUFBUSxDQUFDO0FBQ0xYLE1BQUFBLElBQUksRUFBRWpDLFVBQVUsQ0FBQ2tDLFlBRFo7QUFFTEYsTUFBQUEsT0FBTyxFQUFFO0FBQ0xJLFFBQUFBLEVBQUUsRUFBRVcsS0FBSyxDQUFDQyxNQUFOLENBQWFaLEVBRFo7QUFFTHBCLFFBQUFBLEtBQUssRUFBRStCLEtBQUssQ0FBQ0MsTUFBTixDQUFhaEM7QUFGZjtBQUZKLEtBQUQsQ0FBUjtBQU9ILEdBUndFLEVBUXRFLEVBUnNFLENBQXpFO0FBVUEsU0FBTztBQUFFMkIsSUFBQUEsU0FBUyxFQUFUQSxTQUFGO0FBQWFNLElBQUFBLGVBQWUsRUFBZkEsZUFBYjtBQUE4QkgsSUFBQUEsY0FBYyxFQUFkQSxjQUE5QjtBQUE4Q0QsSUFBQUEsWUFBWSxFQUFaQTtBQUE5QyxHQUFQO0FBQ0g7O2VBRWNILE8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWR1Y2VyLCB1c2VDYWxsYmFjaywgUmVkdWNlciB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHtcbiAgICBWYWxpZGF0b3IsXG4gICAgVmFsaWRhdGlvblR5cGUsXG4gICAgQ3VzdG9tVmFsaWRhdGlvblJ1bGUsXG4gICAgZ2V0VmFsaWRhdG9yLFxuICAgIHZhbGlkYXRlLFxuICAgIHZhbGlkYXRlU3RhdGVcbn0gZnJvbSAnLi9mb3JtLnZhbGlkYXRpb24nO1xuXG5lbnVtIEZvcm1BY3Rpb24ge1xuICAgIElOUFVUX0NIQU5HRSA9ICdJTlBVVF9DSEFOR0UnLFxuICAgIElOUFVUX1RPVUNIID0gJ0lOUFVUX1RPVUNIJyxcbiAgICBTRVRfRk9STSA9ICdTRVRfRk9STSdcbn1cblxuaW50ZXJmYWNlIEZvcm1QYXlsb2FkIGV4dGVuZHMgUGljazxGb3JtRW50cnlTdGF0ZTxhbnk+LCAndmFsdWUnPiB7XG4gICAgcmVhZG9ubHkgaWQ6IHN0cmluZztcbiAgICByZWFkb25seSBzdGF0ZT86IEZvcm1TdGF0ZTxhbnk+O1xufVxuXG50eXBlIEZvcm1FbGVtZW50Q29uc3RyYWludCA9IEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50IHwgSFRNTFNlbGVjdEVsZW1lbnQgfCBIVE1MT3B0aW9uRWxlbWVudDtcblxudHlwZSBSZWR1Y2VyQWN0aW9uID0geyB0eXBlOiBGb3JtQWN0aW9uOyBwYXlsb2FkOiBGb3JtUGF5bG9hZCB9O1xuXG50eXBlIEdldElucHV0T3B0aW9uczxUIGV4dGVuZHMgRm9ybVZhbHVlVHlwZSwgUyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQgPSBhbnk+ID0ge1xuICAgIFtrZXk6IHN0cmluZ106IFQgfCBudW1iZXIgfCBib29sZWFuIHwgQ3VzdG9tVmFsaWRhdGlvblJ1bGU8VCwgUz4gfCBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcbiAgICBtaW5MZW5ndGg/OiBudW1iZXI7XG4gICAgbWF4TGVuZ3RoPzogbnVtYmVyO1xuICAgIG1pblZhbHVlPzogbnVtYmVyO1xuICAgIG1heFZhbHVlPzogbnVtYmVyO1xuICAgIG1pblVwcGVyY2FzZUNoYXJhY3RlcnM/OiBudW1iZXI7XG4gICAgbWF4VXBwZXJjYXNlQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtaW5OdW1lcmljYWxTeW1ib2xzPzogbnVtYmVyO1xuICAgIG1heE51bWVyaWNhbFN5bWJvbHM/OiBudW1iZXI7XG4gICAgaXNSZXF1aXJlZD86IGJvb2xlYW47XG4gICAgaXNWYWxpZD86IGJvb2xlYW47XG4gICAgaXNUb3VjaGVkPzogYm9vbGVhbjtcbiAgICBjdXN0b21SdWxlPzogQ3VzdG9tVmFsaWRhdGlvblJ1bGU8VCwgUz47XG4gICAgY29ubmVjdEZpZWxkcz86IHN0cmluZ1tdO1xufTtcblxuLyogVGhpcyBpcyB0aGUgYmFzZSBmb3IgYW55IGlucHV0IGVudHJ5IGluIGEgJ2Zvcm1TdGF0ZScuIEluIG90aGVyIHdvcmRzXG4gICBhbGwgaW5wdXQgZW50cmllcyB3aWxsIGhhdmUgdGhlc2UgcHJvcGVydGllcyBhdmFpbGFibGUuICovXG50eXBlIEZvcm1FbnRyeVN0YXRlPFQgZXh0ZW5kcyBGb3JtVmFsdWVUeXBlPiA9IHtcbiAgICB2YWx1ZTogVDtcbiAgICBpc1ZhbGlkOiBib29sZWFuO1xuICAgIGlzVG91Y2hlZDogYm9vbGVhbjtcbiAgICByZWFkb25seSB2YWxpZGF0b3JzOiBWYWxpZGF0b3JbXTtcbiAgICByZWFkb25seSBjb25uZWN0ZWRGaWVsZHM6IHN0cmluZ1tdO1xufTtcblxuLyogVGhlIHR5cGUgb2Ygb2JqZWN0IHJldHVybmVkIGJ5IHVzZUZvcm0gd2hlbiBpbml0aWFsaXplZC4gKi9cbmV4cG9ydCB0eXBlIFVzZUZvcm08UyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+ID0ge1xuICAgIC8qKlxuICAgICAqIGZvcm1TdGF0ZScgd2lsbCBhbHdheXMgaGF2ZSBwcm9wZXJ0aWVzICdpbnB1dHMnIGFuZCAnaXNWYWxpZCdcbiAgICAgKiBhdmFpbGFibGUgd2hpbGUgdGhlICdpbnB1dHMnIHByb3BlcnR5LCBpZiBub24tZW1wdHksIHdpbGxcbiAgICAgKiBoYXZlIGtleXMgdGhhdCB5aWVsZHMgYW4gb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGVcbiAgICAgKi9cbiAgICBmb3JtU3RhdGU6IEZvcm1TdGF0ZTxTPjtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdG91Y2ggZXZlbnRzLiBDYW4gYmUgdXNlZCB3aXRoIHByb3AgJ29uQmx1cicsIGZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogXFw8aW5wdXQgb25CbHVyPXtvblRvdWNoSGFuZGxlcn0gL1xcPlxuICAgICAqXG4gICAgICovXG4gICAgb25Ub3VjaEhhbmRsZXI6IFJlYWN0LkZvY3VzRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD47XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNoYW5nZSBldmVudHMuIENhbiBiZSB1c2VkIHdpdGggcHJvcCAnb25DaGFuZ2UnLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIFxcPGlucHV0IG9uQ2hhbmdlPXtvbkNoYW5nZUhhbmRsZXJ9IC9cXD5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2hhbmdlSGFuZGxlcjogUmVhY3QuQ2hhbmdlRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD47XG5cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgZXhpc3RpbmcgaW5wdXRzIGJ5IHNldHRpbmcgbmV3IG9uZXM6XG4gICAgICpcbiAgICAgKiBzZXRGb3JtU3RhdGUoe1xuICAgICAqICAgICAuLi5uZXdJbnB1dHNcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogT3IgYWRkIHRvIGN1cnJlbnQgaW5wdXRzOlxuICAgICAqXG4gICAgICogc2V0Rm9ybVN0YXRlKHtcbiAgICAgKiAgICAgLi4uZm9ybVN0YXRlLmlucHV0cyxcbiAgICAgKiAgICAgLi4ubmV3SW5wdXRzXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBPYmplY3Qgd2l0aCB0aGUgbmV3IEZvcm1TdGF0ZVxuICAgICAqL1xuICAgIHNldEZvcm1TdGF0ZTogKHN0YXRlOiBGb3JtU3RhdGU8Uz4gfCBJbnB1dHM8Uz4pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgdHlwZSBJbnB1dHM8VCBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+ID0geyBbSyBpbiBrZXlvZiBUXTogRm9ybUVudHJ5U3RhdGU8VFtLXT4gfTtcblxuLy8gU3VwcG9ydGVkIGlucHV0IHZhbGVzLiBDYW4gYmUgZXh0ZW5kZWQgaWYgbmVlZCBiZS5cbmV4cG9ydCB0eXBlIEZvcm1WYWx1ZVR5cGUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRmlsZTtcblxuLyogUHJvcGVydHkgbmFtZXMgYW5kIHR5cGVzIG9mIGlucHV0cywgZm9yIGV4YW1wbGU6XG4gICB7IHBhc3N3b3JkOiBzdHJpbmc7IGFnZTogbnVtYmVyOyBpc0hhcHB5OiBib29sZWFuOyB9ICovXG5leHBvcnQgdHlwZSBGb3JtRW50cnlDb25zdHJhaW50ID0geyBba2V5OiBzdHJpbmddOiBGb3JtVmFsdWVUeXBlIH07XG5cbmV4cG9ydCB0eXBlIEZvcm1TdGF0ZTxUIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4gPSB7XG4gICAgaW5wdXRzOiBJbnB1dHM8VD47XG4gICAgaXNWYWxpZDogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCBvZiB0eXBlIEZvcm1FbnRyeVN0YXRlIGJ5IGp1c3QgZGVmaW5pbmcgdGhlIGlucHV0IHR5cGUsIGluaXRpYWwgdmFsdWUgYW5kIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIGluaXRpYWxWYWx1ZSAtIGluaXRpYWwgdmFsdWUgb2YgdGhlIGlucHV0IGVudHJ5LlxuICogQHBhcmFtIG9wdGlvbnMgICAgICAtIChvcHRpb25hbCkgb3B0aW9ucyBmb3IgaW5pdGlhbCBpbnB1dCBzdGF0ZSBhbmQgdmFsaWRhdGlvblxuICogQHJldHVybnMgT2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElucHV0PFQgZXh0ZW5kcyBGb3JtVmFsdWVUeXBlLCBTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludCA9IGFueT4oXG4gICAgaW5pdGlhbFZhbHVlOiBULFxuICAgIG9wdGlvbnM/OiBHZXRJbnB1dE9wdGlvbnM8VCwgUz5cbik6IEZvcm1FbnRyeVN0YXRlPFQ+IHtcbiAgICBjb25zdCBwYXJzZWRPcHRpb25zOiBPbWl0PEZvcm1FbnRyeVN0YXRlPFQ+LCAndmFsdWUnPiA9IHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGlzVG91Y2hlZDogZmFsc2UsXG4gICAgICAgIHZhbGlkYXRvcnM6IFtdLFxuICAgICAgICBjb25uZWN0ZWRGaWVsZHM6IG9wdGlvbnM/LmNvbm5lY3RGaWVsZHMgfHwgW11cbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBwYXJzZWRPcHRpb25zLmlzVG91Y2hlZCA9ICEhb3B0aW9ucy5pc1RvdWNoZWQ7XG4gICAgICAgIHBhcnNlZE9wdGlvbnMuaXNWYWxpZCA9ICEhb3B0aW9ucy5pc1ZhbGlkO1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFbJ2lzVmFsaWQnLCAnaXNUb3VjaGVkJywgJ2Nvbm5lY3RlZEZpZWxkcyddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRPcHRpb25zLnZhbGlkYXRvcnMucHVzaChnZXRWYWxpZGF0b3Ioa2V5IGFzIFZhbGlkYXRpb25UeXBlLCBvcHRpb25zW2tleV0gYXMgVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGFyc2VkT3B0aW9ucyxcbiAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZVxuICAgIH07XG59XG5cbi8qKlxuICogSGFuZGxlIGFsbCBjb25uZWN0ZWQgZmllbGRzIHRpZWQgdG8gYSBjZXJ0YWluIGlucHV0LiBUaGlzIGlzIHVzZWZ1bCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb246XG4gKlxuICogSWYgd2UgaGF2ZSBpbnB1dCBBIGFuZCBpbnB1dCBCIGFuZCBpbnB1dCBCIGlzIGRlcGVuZGVudCB1cG9uIGlucHV0IEEuIFRoZW4gd2UnZCBsaWtlIHRvIGJlIGFibGUgdG9cbiAqIHJ1biB0aGUgdmFsaWRhdGlvbiBmb3IgaW5wdXQgQiBlYWNoIHRpbWUgdGhlIHZhbHVlIG9mIGlucHV0IEEgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgICAtIGN1cnJlbnQgRm9ybVN0YXRlIHdoZXJlIHRoZSBjb25uZWN0ZWQgaW5wdXRzIGNhbiBiZSBmb3VuZFxuICogQHBhcmFtIHRhcmdldElkIC0gSWQgb2YgdGhlIG93bmluZyBpbnB1dCAoaW5wdXQgQSBpbiB0aGUgZXhhbXBsZSBhYm92ZSlcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGVudHJ5IGtleXMgYW5kIHRoZWlyIHVwZGF0ZWQgb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGVcbiAqL1xuY29uc3QgaGFuZGxlQ29ubmVjdGVkRmllbGRzID0gKHN0YXRlOiBGb3JtU3RhdGU8YW55PiwgdGFyZ2V0SWQ6IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogRm9ybUVudHJ5U3RhdGU8YW55PiB9ID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdJbnB1dFN0YXRlID0geyAuLi5zdGF0ZS5pbnB1dHMgfTtcbiAgICAgICAgLy8gZmluZCBjb25uZWN0ZWQgZmllbGRzIGZyb20gdGhlIHRhcmdldElkXG4gICAgICAgIG5ld0lucHV0U3RhdGVbdGFyZ2V0SWRdLmNvbm5lY3RlZEZpZWxkcy5mb3JFYWNoKChjb25uZWN0ZWRGaWVsZElkKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgY29ubmVjdGVkIGZpZWxkIGV4aXN0c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdJbnB1dFN0YXRlW2Nvbm5lY3RlZEZpZWxkSWRdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gdmFsaWRhdGUgaXQgZ2l2ZW4gdGhlIHNwZWNpZmllZCBzdGF0ZVxuICAgICAgICAgICAgICAgIG5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0sXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0udmFsaWRhdG9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0lucHV0U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gc3RhdGUuaW5wdXRzO1xuICAgIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGNoYW5nZXMgdG8gRm9ybVN0YXRlIGdpdmVuIGFuIGFjdGlvbiBhc3NvY2lhdGVkIHdpdGggYSBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSBPYmplY3Qgd2l0aCBjdXJyZW50IEZvcm1TdGF0ZVxuICogQHBhcmFtIGFjdGlvbiBGb3JtQWN0aW9uIGFuZCBGb3JtUGF5bG9hZCB0byBoYW5kbGVcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHRoZSB1cGRhdGVkIEZvcm1TdGF0ZVxuICovXG5mdW5jdGlvbiBmb3JtUmVkdWNlcjxTIGV4dGVuZHMgRm9ybVN0YXRlPGFueT4+KHN0YXRlOiBTLCBhY3Rpb246IFJlZHVjZXJBY3Rpb24pOiBTIHtcbiAgICBjb25zdCBwbCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBGb3JtQWN0aW9uLklOUFVUX0NIQU5HRTpcbiAgICAgICAgICAgIC8vIGNvcHkgdGhlIGN1cnJlbnQgc3RhdGUsIHVwZGF0ZSB0aGUgZW50cnkgd2l0aCB0aGUgc3BlY2lmaWVkIHBheWxvYWQgSWQgYW5kIHZhbGlkYXRlIGl0LlxuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGU6IFMgPSB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgW3BsLmlkXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzW3BsLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwbC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkYXRlKHBsLnZhbHVlLCBzdGF0ZS5pbnB1dHNbcGwuaWRdLnZhbGlkYXRvcnMsIHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNvcHkgdGhlIGlucHV0cyBhbmQgdmFsaWRhdGUgY29ubmVjdGVkIGZpZWxkcyBnaXZlbiB0aGUgbm93IHVwZGF0ZWQgc3RhdGUuXG4gICAgICAgICAgICBuZXdTdGF0ZS5pbnB1dHMgPSB7XG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuaW5wdXRzLFxuICAgICAgICAgICAgICAgIC4uLmhhbmRsZUNvbm5lY3RlZEZpZWxkcyhuZXdTdGF0ZSwgcGwuaWQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSB1cGRhdGVkIEZvcm1TdGF0ZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuaW5wdXRzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiB2YWxpZGF0ZVN0YXRlKG5ld1N0YXRlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBGb3JtQWN0aW9uLklOUFVUX1RPVUNIOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICBbcGwuaWRdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbnB1dHNbcGwuaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIEZvcm1BY3Rpb24uU0VUX0ZPUk06XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsLnN0YXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLihwbC5zdGF0ZSBhcyBTKSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZTxTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4oaW5pdGlhbFN0YXRlOiBGb3JtU3RhdGU8Uz4gfCBJbnB1dHM8Uz4pOiBGb3JtU3RhdGU8Uz4ge1xuICAgIGxldCBzdGF0ZTogRm9ybVN0YXRlPFM+O1xuICAgIGlmIChcbiAgICAgICAgT2JqZWN0LmtleXMoaW5pdGlhbFN0YXRlKS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgdHlwZW9mIGluaXRpYWxTdGF0ZS5pbnB1dHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBpbml0aWFsU3RhdGUuaXNWYWxpZCAhPT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgICAgc3RhdGUgPSB7IC4uLihpbml0aWFsU3RhdGUgYXMgRm9ybVN0YXRlPFM+KSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgaW5wdXRzOiB7IC4uLihpbml0aWFsU3RhdGUgYXMgSW5wdXRzPFM+KSB9LFxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUuaXNWYWxpZCA9IHZhbGlkYXRlU3RhdGUoc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogUmVhY3QgaG9vayBmb3IgbWFuYWdpbmcgdGhlIHN0YXRlIG9mIGEgZm9ybSBhbmQgaXRzIGFzc29jaWF0ZWQgaW5wdXRzLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgLSBPYmplY3Qgd2l0aCBpbml0aWFsIEZvcm1TdGF0ZSBvciBpbml0aWFsIElucHV0c1xuXG4gKiBAcmV0dXJucyBPYmplY3Qgb2YgVXNlRm9ybSB0eXBlIHdpdGggc3BlY2lmaWVkIHByb3BlcnRpZXMgYW5kIHR5cGVzLlxuICovXG5mdW5jdGlvbiB1c2VGb3JtPFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50Pihpbml0aWFsU3RhdGU6IEZvcm1TdGF0ZTxTPiB8IElucHV0czxTPik6IFVzZUZvcm08Uz4ge1xuICAgIGNvbnN0IFtmb3JtU3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXI8UmVkdWNlcjxGb3JtU3RhdGU8Uz4sIFJlZHVjZXJBY3Rpb24+Pihmb3JtUmVkdWNlciwge1xuICAgICAgICAuLi5nZXRTdGF0ZShpbml0aWFsU3RhdGUpXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZXRGb3JtU3RhdGUgPSB1c2VDYWxsYmFjaygoc3RhdGU6IEZvcm1TdGF0ZTxTPiB8IElucHV0czxTPik6IHZvaWQgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IEZvcm1BY3Rpb24uU0VUX0ZPUk0sIHBheWxvYWQ6IHsgc3RhdGU6IHsgLi4uZ2V0U3RhdGUoc3RhdGUpIH0sIHZhbHVlOiAnJywgaWQ6ICcnIH0gfSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgb25Ub3VjaEhhbmRsZXI6IFJlYWN0LkZvY3VzRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD4gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiBGb3JtQWN0aW9uLklOUFVUX1RPVUNILCBwYXlsb2FkOiB7IGlkOiBldmVudC50YXJnZXQuaWQsIHZhbHVlOiAnJyB9IH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uQ2hhbmdlSGFuZGxlcjogUmVhY3QuQ2hhbmdlRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD4gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogRm9ybUFjdGlvbi5JTlBVVF9DSEFOR0UsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LnRhcmdldC5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IGZvcm1TdGF0ZSwgb25DaGFuZ2VIYW5kbGVyLCBvblRvdWNoSGFuZGxlciwgc2V0Rm9ybVN0YXRlIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUZvcm07XG4iXX0=