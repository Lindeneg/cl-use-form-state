"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInput = getInput;
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

var _form = require("./form.validation");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var FormAction;

(function (FormAction) {
  FormAction["INPUT_CHANGE"] = "INPUT_CHANGE";
  FormAction["INPUT_TOUCH"] = "INPUT_TOUCH";
  FormAction["SET_FORM"] = "SET_FORM";
})(FormAction || (FormAction = {}));

/**
 * Get an object of type FormEntryState by just defining the input type, initial value and options.
 *
 * @param initialValue - initial value of the input entry.
 * @param options      - (optional) options for initial input state and validation
 * @returns Object of type FormEntryState
 */
function getInput(initialValue, options) {
  var parsedOptions = {
    isValid: false,
    isTouched: false,
    validators: [],
    connectedFields: (options === null || options === void 0 ? void 0 : options.connectFields) || []
  };

  if (typeof options !== 'undefined') {
    var keys = Object.keys(options);
    parsedOptions.isTouched = !!options.isTouched;
    parsedOptions.isValid = !!options.isValid;
    keys.forEach(function (key) {
      if (!['isValid', 'isTouched', 'connectedFields'].includes(key)) {
        parsedOptions.validators.push((0, _form.getValidator)(key, options[key]));
      }
    });
  }

  return _objectSpread(_objectSpread({}, parsedOptions), {}, {
    value: initialValue
  });
}
/**
 * Handle all connected fields tied to a certain input. This is useful for the following reason:
 *
 * If we have input A and input B and input B is dependent upon input A. Then we'd like to be able to
 * run the validation for input B each time the value of input A changes.
 *
 * @param state   - current FormState where the connected inputs can be found
 * @param targetId - Id of the owning input (input A in the example above)
 * @returns An object with entry keys and their updated object of type FormEntryState
 */


var handleConnectedFields = function handleConnectedFields(state, targetId) {
  try {
    var newInputState = _objectSpread({}, state.inputs); // find connected fields from the targetId


    newInputState[targetId].connectedFields.forEach(function (connectedFieldId) {
      // if the connected field exists
      if (typeof newInputState[connectedFieldId] !== 'undefined') {
        // then validate it given the specified state
        newInputState[connectedFieldId] = _objectSpread(_objectSpread({}, newInputState[connectedFieldId]), {}, {
          isValid: (0, _form.validate)(newInputState[connectedFieldId].value, newInputState[connectedFieldId].validators, state)
        });
      }
    });
    return newInputState;
  } catch (err) {
    process.env.NODE_ENV !== 'production' && console.error(err);
    return state.inputs;
  }
};
/**
 * Handle changes to FormState given an action associated with a payload.
 *
 * @param state Object with current FormState
 * @param action FormAction and FormPayload to handle
 * @returns Object with the updated FormState
 */


function formReducer(state, action) {
  var pl = action.payload;

  switch (action.type) {
    case FormAction.INPUT_CHANGE:
      try {
        // copy the current state, update the entry with the specified payload Id and validate it.
        var newState = _objectSpread(_objectSpread({}, state), {}, {
          inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
            value: pl.value,
            isValid: (0, _form.validate)(pl.value, state.inputs[pl.id].validators, state)
          })))
        }); // copy the inputs and validate connected fields given the now updated state.


        newState.inputs = _objectSpread(_objectSpread({}, newState.inputs), handleConnectedFields(newState, pl.id)); // return the updated FormState

        return _objectSpread(_objectSpread({}, newState), {}, {
          inputs: _objectSpread({}, newState.inputs),
          isValid: (0, _form.validateState)(newState)
        });
      } catch (err) {
        console.error("use-form-state cannot recognize input-id '".concat(pl.id, "'. Please make sure that all form input names are tied to a form element, such as <input id='{ID}' />."));
        break;
      }

    case FormAction.INPUT_TOUCH:
      try {
        return _objectSpread(_objectSpread({}, state), {}, {
          inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
            isTouched: true
          })))
        });
      } catch (err) {
        console.error("use-form-state cannot recognize input-id '".concat(pl.id, "'. Please make sure that all form input names are tied to a form element, such as <input id='{ID}' />."));
        break;
      }

    case FormAction.SET_FORM:
      if (typeof pl.state !== 'undefined') {
        return _objectSpread({}, pl.state);
      } else {
        return state;
      }

    default:
      break;
  }

  return state;
}

function getState(initialState) {
  var state;

  if (Object.keys(initialState).length === 2 && typeof initialState.inputs !== 'undefined' && typeof initialState.isValid !== 'undefined') {
    state = _objectSpread({}, initialState);
  } else {
    state = {
      inputs: _objectSpread({}, initialState),
      isValid: false
    };
    state.isValid = (0, _form.validateState)(state);
  }

  return state;
}
/**
 * React hook for managing the state of a form and its associated inputs.
 *
 * @param initialState - Object with initial FormState or initial Inputs

 * @returns Object of UseForm type with specified properties and types.
 */


function useForm(initialState) {
  var _useReducer = (0, _react.useReducer)(formReducer, _objectSpread({}, getState(initialState))),
      _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
      formState = _useReducer2[0],
      dispatch = _useReducer2[1];

  var setFormState = (0, _react.useCallback)(function (state) {
    dispatch({
      type: FormAction.SET_FORM,
      payload: {
        state: _objectSpread({}, getState(state)),
        value: '',
        id: ''
      }
    });
  }, []);
  var onTouchHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_TOUCH,
      payload: {
        id: event.target.id,
        value: ''
      }
    });
  }, []);
  var onChangeHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_CHANGE,
      payload: {
        id: event.target.id,
        value: event.target.value
      }
    });
  }, []);
  return {
    formState: formState,
    onChangeHandler: onChangeHandler,
    onTouchHandler: onTouchHandler,
    setFormState: setFormState
  };
}

var _default = useForm;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mb3JtLmhvb2sudHMiXSwibmFtZXMiOlsiRm9ybUFjdGlvbiIsImdldElucHV0IiwiaW5pdGlhbFZhbHVlIiwib3B0aW9ucyIsInBhcnNlZE9wdGlvbnMiLCJpc1ZhbGlkIiwiaXNUb3VjaGVkIiwidmFsaWRhdG9ycyIsImNvbm5lY3RlZEZpZWxkcyIsImNvbm5lY3RGaWVsZHMiLCJrZXlzIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicHVzaCIsInZhbHVlIiwiaGFuZGxlQ29ubmVjdGVkRmllbGRzIiwic3RhdGUiLCJ0YXJnZXRJZCIsIm5ld0lucHV0U3RhdGUiLCJpbnB1dHMiLCJjb25uZWN0ZWRGaWVsZElkIiwiZXJyIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwiZm9ybVJlZHVjZXIiLCJhY3Rpb24iLCJwbCIsInBheWxvYWQiLCJ0eXBlIiwiSU5QVVRfQ0hBTkdFIiwibmV3U3RhdGUiLCJpZCIsIklOUFVUX1RPVUNIIiwiU0VUX0ZPUk0iLCJnZXRTdGF0ZSIsImluaXRpYWxTdGF0ZSIsImxlbmd0aCIsInVzZUZvcm0iLCJmb3JtU3RhdGUiLCJkaXNwYXRjaCIsInNldEZvcm1TdGF0ZSIsIm9uVG91Y2hIYW5kbGVyIiwiZXZlbnQiLCJ0YXJnZXQiLCJvbkNoYW5nZUhhbmRsZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7Ozs7OztJQVNLQSxVOztXQUFBQSxVO0FBQUFBLEVBQUFBLFU7QUFBQUEsRUFBQUEsVTtBQUFBQSxFQUFBQSxVO0dBQUFBLFUsS0FBQUEsVTs7QUFvR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQyxRQUFULENBQ0hDLFlBREcsRUFFSEMsT0FGRyxFQUdjO0FBQ2pCLE1BQU1DLGFBQStDLEdBQUc7QUFDcERDLElBQUFBLE9BQU8sRUFBRSxLQUQyQztBQUVwREMsSUFBQUEsU0FBUyxFQUFFLEtBRnlD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SUEsTUFBTVUsY0FBOEQsR0FBRyx3QkFBWSxVQUFDQyxLQUFELEVBQVc7QUFDMUZILElBQUFBLFFBQVEsQ0FBQztBQUFFWCxNQUFBQSxJQUFJLEVBQUVqQyxVQUFVLENBQUNxQyxXQUFuQjtBQUFnQ0wsTUFBQUEsT0FBTyxFQUFFO0FBQUVJLFFBQUFBLEVBQUUsRUFBRVcsS0FBSyxDQUFDQyxNQUFOLENBQWFaLEVBQW5CO0FBQXVCcEIsUUFBQUEsS0FBSyxFQUFFO0FBQTlCO0FBQXpDLEtBQUQsQ0FBUjtBQUNILEdBRnNFLEVBRXBFLEVBRm9FLENBQXZFO0FBSUEsTUFBTWlDLGVBQWdFLEdBQUcsd0JBQVksVUFBQ0YsS0FBRCxFQUFXO0FBQzVGSCxJQUFBQSxRQUFRLENBQUM7QUFDTFgsTUFBQUEsSUFBSSxFQUFFakMsVUFBVSxDQUFDa0MsWUFEWjtBQUVMRixNQUFBQSxPQUFPLEVBQUU7QUFDTEksUUFBQUEsRUFBRSxFQUFFVyxLQUFLLENBQUNDLE1BQU4sQ0FBYVosRUFEWjtBQUVMcEIsUUFBQUEsS0FBSyxFQUFFK0IsS0FBSyxDQUFDQyxNQUFOLENBQWFoQztBQUZmO0FBRkosS0FBRCxDQUFSO0FBT0gsR0FSd0UsRUFRdEUsRUFSc0UsQ0FBekU7QUFVQSxTQUFPO0FBQUUyQixJQUFBQSxTQUFTLEVBQVRBLFNBQUY7QUFBYU0sSUFBQUEsZUFBZSxFQUFmQSxlQUFiO0FBQThCSCxJQUFBQSxjQUFjLEVBQWRBLGNBQTlCO0FBQThDRCxJQUFBQSxZQUFZLEVBQVpBO0FBQTlDLEdBQVA7QUFDSDs7ZUFFY0gsTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZUNhbGxiYWNrLCBSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge1xuICAgIFZhbGlkYXRvcixcbiAgICBWYWxpZGF0aW9uVHlwZSxcbiAgICBDdXN0b21WYWxpZGF0aW9uUnVsZSxcbiAgICBnZXRWYWxpZGF0b3IsXG4gICAgdmFsaWRhdGUsXG4gICAgdmFsaWRhdGVTdGF0ZVxufSBmcm9tICcuL2Zvcm0udmFsaWRhdGlvbic7XG5cbmVudW0gRm9ybUFjdGlvbiB7XG4gICAgSU5QVVRfQ0hBTkdFID0gJ0lOUFVUX0NIQU5HRScsXG4gICAgSU5QVVRfVE9VQ0ggPSAnSU5QVVRfVE9VQ0gnLFxuICAgIFNFVF9GT1JNID0gJ1NFVF9GT1JNJ1xufVxuXG5pbnRlcmZhY2UgRm9ybVBheWxvYWQgZXh0ZW5kcyBQaWNrPEZvcm1FbnRyeVN0YXRlPGFueT4sICd2YWx1ZSc+IHtcbiAgICByZWFkb25seSBpZDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHN0YXRlPzogRm9ybVN0YXRlPGFueT47XG59XG5cbnR5cGUgRm9ybUVsZW1lbnRDb25zdHJhaW50ID0gSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQgfCBIVE1MU2VsZWN0RWxlbWVudCB8IEhUTUxPcHRpb25FbGVtZW50O1xuXG50eXBlIFJlZHVjZXJBY3Rpb24gPSB7IHR5cGU6IEZvcm1BY3Rpb247IHBheWxvYWQ6IEZvcm1QYXlsb2FkIH07XG5cbi8qIFRoaXMgaXMgdGhlIGJhc2UgZm9yIGFueSBpbnB1dCBlbnRyeSBpbiBhICdmb3JtU3RhdGUnLiBJbiBvdGhlciB3b3Jkc1xuICAgYWxsIGlucHV0IGVudHJpZXMgd2lsbCBoYXZlIHRoZXNlIHByb3BlcnRpZXMgYXZhaWxhYmxlLiAqL1xudHlwZSBGb3JtRW50cnlTdGF0ZTxUIGV4dGVuZHMgRm9ybVZhbHVlVHlwZT4gPSB7XG4gICAgdmFsdWU6IFQ7XG4gICAgaXNWYWxpZDogYm9vbGVhbjtcbiAgICBpc1RvdWNoZWQ6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgdmFsaWRhdG9yczogVmFsaWRhdG9yW107XG4gICAgcmVhZG9ubHkgY29ubmVjdGVkRmllbGRzOiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCB0eXBlIEdldElucHV0T3B0aW9uczxUIGV4dGVuZHMgRm9ybVZhbHVlVHlwZSwgUyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQgPSBhbnk+ID0ge1xuICAgIFtrZXk6IHN0cmluZ106IFQgfCBudW1iZXIgfCBib29sZWFuIHwgQ3VzdG9tVmFsaWRhdGlvblJ1bGU8VCwgUz4gfCBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcbiAgICBtaW5MZW5ndGg/OiBudW1iZXI7XG4gICAgbWF4TGVuZ3RoPzogbnVtYmVyO1xuICAgIG1pblZhbHVlPzogbnVtYmVyO1xuICAgIG1heFZhbHVlPzogbnVtYmVyO1xuICAgIG1pblVwcGVyY2FzZUNoYXJhY3RlcnM/OiBudW1iZXI7XG4gICAgbWF4VXBwZXJjYXNlQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtaW5OdW1lcmljYWxTeW1ib2xzPzogbnVtYmVyO1xuICAgIG1heE51bWVyaWNhbFN5bWJvbHM/OiBudW1iZXI7XG4gICAgaXNSZXF1aXJlZD86IGJvb2xlYW47XG4gICAgaXNWYWxpZD86IGJvb2xlYW47XG4gICAgaXNUb3VjaGVkPzogYm9vbGVhbjtcbiAgICBjdXN0b21SdWxlPzogQ3VzdG9tVmFsaWRhdGlvblJ1bGU8VCwgUz47XG4gICAgY29ubmVjdEZpZWxkcz86IHN0cmluZ1tdO1xufTtcblxuLyogVGhlIHR5cGUgb2Ygb2JqZWN0IHJldHVybmVkIGJ5IHVzZUZvcm0gd2hlbiBpbml0aWFsaXplZC4gKi9cbmV4cG9ydCB0eXBlIFVzZUZvcm08UyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+ID0ge1xuICAgIC8qKlxuICAgICAqIGZvcm1TdGF0ZScgd2lsbCBhbHdheXMgaGF2ZSBwcm9wZXJ0aWVzICdpbnB1dHMnIGFuZCAnaXNWYWxpZCdcbiAgICAgKiBhdmFpbGFibGUgd2hpbGUgdGhlICdpbnB1dHMnIHByb3BlcnR5LCBpZiBub24tZW1wdHksIHdpbGxcbiAgICAgKiBoYXZlIGtleXMgdGhhdCB5aWVsZHMgYW4gb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGVcbiAgICAgKi9cbiAgICBmb3JtU3RhdGU6IEZvcm1TdGF0ZTxTPjtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdG91Y2ggZXZlbnRzLiBDYW4gYmUgdXNlZCB3aXRoIHByb3AgJ29uQmx1cicsIGZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogXFw8aW5wdXQgb25CbHVyPXtvblRvdWNoSGFuZGxlcn0gL1xcPlxuICAgICAqXG4gICAgICovXG4gICAgb25Ub3VjaEhhbmRsZXI6IFJlYWN0LkZvY3VzRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD47XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNoYW5nZSBldmVudHMuIENhbiBiZSB1c2VkIHdpdGggcHJvcCAnb25DaGFuZ2UnLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIFxcPGlucHV0IG9uQ2hhbmdlPXtvbkNoYW5nZUhhbmRsZXJ9IC9cXD5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2hhbmdlSGFuZGxlcjogUmVhY3QuQ2hhbmdlRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD47XG5cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgZXhpc3RpbmcgaW5wdXRzIGJ5IHNldHRpbmcgbmV3IG9uZXM6XG4gICAgICpcbiAgICAgKiBzZXRGb3JtU3RhdGUoe1xuICAgICAqICAgICAuLi5uZXdJbnB1dHNcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogT3IgYWRkIHRvIGN1cnJlbnQgaW5wdXRzOlxuICAgICAqXG4gICAgICogc2V0Rm9ybVN0YXRlKHtcbiAgICAgKiAgICAgLi4uZm9ybVN0YXRlLmlucHV0cyxcbiAgICAgKiAgICAgLi4ubmV3SW5wdXRzXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBPYmplY3Qgd2l0aCB0aGUgbmV3IEZvcm1TdGF0ZVxuICAgICAqL1xuICAgIHNldEZvcm1TdGF0ZTogKHN0YXRlOiBGb3JtU3RhdGU8Uz4gfCBJbnB1dHM8Uz4pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgdHlwZSBJbnB1dHM8VCBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+ID0geyBbSyBpbiBrZXlvZiBUXTogRm9ybUVudHJ5U3RhdGU8VFtLXT4gfTtcblxuLy8gU3VwcG9ydGVkIGlucHV0IHZhbGVzLiBDYW4gYmUgZXh0ZW5kZWQgaWYgbmVlZCBiZS5cbmV4cG9ydCB0eXBlIEZvcm1WYWx1ZVR5cGUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRmlsZTtcblxuLyogUHJvcGVydHkgbmFtZXMgYW5kIHR5cGVzIG9mIGlucHV0cywgZm9yIGV4YW1wbGU6XG4gICB7IHBhc3N3b3JkOiBzdHJpbmc7IGFnZTogbnVtYmVyOyBpc0hhcHB5OiBib29sZWFuOyB9ICovXG5leHBvcnQgdHlwZSBGb3JtRW50cnlDb25zdHJhaW50ID0geyBba2V5OiBzdHJpbmddOiBGb3JtVmFsdWVUeXBlIH07XG5cbmV4cG9ydCB0eXBlIEZvcm1TdGF0ZTxUIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4gPSB7XG4gICAgaW5wdXRzOiBJbnB1dHM8VD47XG4gICAgaXNWYWxpZDogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCBvZiB0eXBlIEZvcm1FbnRyeVN0YXRlIGJ5IGp1c3QgZGVmaW5pbmcgdGhlIGlucHV0IHR5cGUsIGluaXRpYWwgdmFsdWUgYW5kIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIGluaXRpYWxWYWx1ZSAtIGluaXRpYWwgdmFsdWUgb2YgdGhlIGlucHV0IGVudHJ5LlxuICogQHBhcmFtIG9wdGlvbnMgICAgICAtIChvcHRpb25hbCkgb3B0aW9ucyBmb3IgaW5pdGlhbCBpbnB1dCBzdGF0ZSBhbmQgdmFsaWRhdGlvblxuICogQHJldHVybnMgT2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElucHV0PFQgZXh0ZW5kcyBGb3JtVmFsdWVUeXBlLCBTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludCA9IGFueT4oXG4gICAgaW5pdGlhbFZhbHVlOiBULFxuICAgIG9wdGlvbnM/OiBHZXRJbnB1dE9wdGlvbnM8VCwgUz5cbik6IEZvcm1FbnRyeVN0YXRlPFQ+IHtcbiAgICBjb25zdCBwYXJzZWRPcHRpb25zOiBPbWl0PEZvcm1FbnRyeVN0YXRlPFQ+LCAndmFsdWUnPiA9IHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGlzVG91Y2hlZDogZmFsc2UsXG4gICAgICAgIHZhbGlkYXRvcnM6IFtdLFxuICAgICAgICBjb25uZWN0ZWRGaWVsZHM6IG9wdGlvbnM/LmNvbm5lY3RGaWVsZHMgfHwgW11cbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBwYXJzZWRPcHRpb25zLmlzVG91Y2hlZCA9ICEhb3B0aW9ucy5pc1RvdWNoZWQ7XG4gICAgICAgIHBhcnNlZE9wdGlvbnMuaXNWYWxpZCA9ICEhb3B0aW9ucy5pc1ZhbGlkO1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFbJ2lzVmFsaWQnLCAnaXNUb3VjaGVkJywgJ2Nvbm5lY3RlZEZpZWxkcyddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRPcHRpb25zLnZhbGlkYXRvcnMucHVzaChnZXRWYWxpZGF0b3Ioa2V5IGFzIFZhbGlkYXRpb25UeXBlLCBvcHRpb25zW2tleV0gYXMgVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGFyc2VkT3B0aW9ucyxcbiAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZVxuICAgIH07XG59XG5cbi8qKlxuICogSGFuZGxlIGFsbCBjb25uZWN0ZWQgZmllbGRzIHRpZWQgdG8gYSBjZXJ0YWluIGlucHV0LiBUaGlzIGlzIHVzZWZ1bCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb246XG4gKlxuICogSWYgd2UgaGF2ZSBpbnB1dCBBIGFuZCBpbnB1dCBCIGFuZCBpbnB1dCBCIGlzIGRlcGVuZGVudCB1cG9uIGlucHV0IEEuIFRoZW4gd2UnZCBsaWtlIHRvIGJlIGFibGUgdG9cbiAqIHJ1biB0aGUgdmFsaWRhdGlvbiBmb3IgaW5wdXQgQiBlYWNoIHRpbWUgdGhlIHZhbHVlIG9mIGlucHV0IEEgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgICAtIGN1cnJlbnQgRm9ybVN0YXRlIHdoZXJlIHRoZSBjb25uZWN0ZWQgaW5wdXRzIGNhbiBiZSBmb3VuZFxuICogQHBhcmFtIHRhcmdldElkIC0gSWQgb2YgdGhlIG93bmluZyBpbnB1dCAoaW5wdXQgQSBpbiB0aGUgZXhhbXBsZSBhYm92ZSlcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGVudHJ5IGtleXMgYW5kIHRoZWlyIHVwZGF0ZWQgb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGVcbiAqL1xuY29uc3QgaGFuZGxlQ29ubmVjdGVkRmllbGRzID0gKHN0YXRlOiBGb3JtU3RhdGU8YW55PiwgdGFyZ2V0SWQ6IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogRm9ybUVudHJ5U3RhdGU8YW55PiB9ID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdJbnB1dFN0YXRlID0geyAuLi5zdGF0ZS5pbnB1dHMgfTtcbiAgICAgICAgLy8gZmluZCBjb25uZWN0ZWQgZmllbGRzIGZyb20gdGhlIHRhcmdldElkXG4gICAgICAgIG5ld0lucHV0U3RhdGVbdGFyZ2V0SWRdLmNvbm5lY3RlZEZpZWxkcy5mb3JFYWNoKChjb25uZWN0ZWRGaWVsZElkKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgY29ubmVjdGVkIGZpZWxkIGV4aXN0c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdJbnB1dFN0YXRlW2Nvbm5lY3RlZEZpZWxkSWRdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gdmFsaWRhdGUgaXQgZ2l2ZW4gdGhlIHNwZWNpZmllZCBzdGF0ZVxuICAgICAgICAgICAgICAgIG5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0sXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0udmFsaWRhdG9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0lucHV0U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gc3RhdGUuaW5wdXRzO1xuICAgIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGNoYW5nZXMgdG8gRm9ybVN0YXRlIGdpdmVuIGFuIGFjdGlvbiBhc3NvY2lhdGVkIHdpdGggYSBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSBPYmplY3Qgd2l0aCBjdXJyZW50IEZvcm1TdGF0ZVxuICogQHBhcmFtIGFjdGlvbiBGb3JtQWN0aW9uIGFuZCBGb3JtUGF5bG9hZCB0byBoYW5kbGVcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHRoZSB1cGRhdGVkIEZvcm1TdGF0ZVxuICovXG5mdW5jdGlvbiBmb3JtUmVkdWNlcjxTIGV4dGVuZHMgRm9ybVN0YXRlPGFueT4+KHN0YXRlOiBTLCBhY3Rpb246IFJlZHVjZXJBY3Rpb24pOiBTIHtcbiAgICBjb25zdCBwbCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBGb3JtQWN0aW9uLklOUFVUX0NIQU5HRTpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gY29weSB0aGUgY3VycmVudCBzdGF0ZSwgdXBkYXRlIHRoZSBlbnRyeSB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZCBJZCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhdGU6IFMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwbC5pZF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbnB1dHNbcGwuaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwbC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiB2YWxpZGF0ZShwbC52YWx1ZSwgc3RhdGUuaW5wdXRzW3BsLmlkXS52YWxpZGF0b3JzLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gY29weSB0aGUgaW5wdXRzIGFuZCB2YWxpZGF0ZSBjb25uZWN0ZWQgZmllbGRzIGdpdmVuIHRoZSBub3cgdXBkYXRlZCBzdGF0ZS5cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5pbnB1dHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uaGFuZGxlQ29ubmVjdGVkRmllbGRzKG5ld1N0YXRlLCBwbC5pZClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgdXBkYXRlZCBGb3JtU3RhdGVcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5pbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZDogdmFsaWRhdGVTdGF0ZShuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYHVzZS1mb3JtLXN0YXRlIGNhbm5vdCByZWNvZ25pemUgaW5wdXQtaWQgJyR7cGwuaWR9Jy4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IGFsbCBmb3JtIGlucHV0IG5hbWVzIGFyZSB0aWVkIHRvIGEgZm9ybSBlbGVtZW50LCBzdWNoIGFzIDxpbnB1dCBpZD0ne0lEfScgLz4uYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgRm9ybUFjdGlvbi5JTlBVVF9UT1VDSDpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3BsLmlkXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmlucHV0c1twbC5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYHVzZS1mb3JtLXN0YXRlIGNhbm5vdCByZWNvZ25pemUgaW5wdXQtaWQgJyR7cGwuaWR9Jy4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IGFsbCBmb3JtIGlucHV0IG5hbWVzIGFyZSB0aWVkIHRvIGEgZm9ybSBlbGVtZW50LCBzdWNoIGFzIDxpbnB1dCBpZD0ne0lEfScgLz4uYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgRm9ybUFjdGlvbi5TRVRfRk9STTpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGwuc3RhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uKHBsLnN0YXRlIGFzIFMpIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlPFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50Pihpbml0aWFsU3RhdGU6IEZvcm1TdGF0ZTxTPiB8IElucHV0czxTPik6IEZvcm1TdGF0ZTxTPiB7XG4gICAgbGV0IHN0YXRlOiBGb3JtU3RhdGU8Uz47XG4gICAgaWYgKFxuICAgICAgICBPYmplY3Qua2V5cyhpbml0aWFsU3RhdGUpLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICB0eXBlb2YgaW5pdGlhbFN0YXRlLmlucHV0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIGluaXRpYWxTdGF0ZS5pc1ZhbGlkICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgICBzdGF0ZSA9IHsgLi4uKGluaXRpYWxTdGF0ZSBhcyBGb3JtU3RhdGU8Uz4pIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBpbnB1dHM6IHsgLi4uKGluaXRpYWxTdGF0ZSBhcyBJbnB1dHM8Uz4pIH0sXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBzdGF0ZS5pc1ZhbGlkID0gdmFsaWRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBSZWFjdCBob29rIGZvciBtYW5hZ2luZyB0aGUgc3RhdGUgb2YgYSBmb3JtIGFuZCBpdHMgYXNzb2NpYXRlZCBpbnB1dHMuXG4gKlxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSAtIE9iamVjdCB3aXRoIGluaXRpYWwgRm9ybVN0YXRlIG9yIGluaXRpYWwgSW5wdXRzXG5cbiAqIEByZXR1cm5zIE9iamVjdCBvZiBVc2VGb3JtIHR5cGUgd2l0aCBzcGVjaWZpZWQgcHJvcGVydGllcyBhbmQgdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHVzZUZvcm08UyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+KGluaXRpYWxTdGF0ZTogRm9ybVN0YXRlPFM+IHwgSW5wdXRzPFM+KTogVXNlRm9ybTxTPiB7XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcjxSZWR1Y2VyPEZvcm1TdGF0ZTxTPiwgUmVkdWNlckFjdGlvbj4+KGZvcm1SZWR1Y2VyLCB7XG4gICAgICAgIC4uLmdldFN0YXRlKGluaXRpYWxTdGF0ZSlcbiAgICB9KTtcblxuICAgIGNvbnN0IHNldEZvcm1TdGF0ZSA9IHVzZUNhbGxiYWNrKChzdGF0ZTogRm9ybVN0YXRlPFM+IHwgSW5wdXRzPFM+KTogdm9pZCA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogRm9ybUFjdGlvbi5TRVRfRk9STSwgcGF5bG9hZDogeyBzdGF0ZTogeyAuLi5nZXRTdGF0ZShzdGF0ZSkgfSwgdmFsdWU6ICcnLCBpZDogJycgfSB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBvblRvdWNoSGFuZGxlcjogUmVhY3QuRm9jdXNFdmVudEhhbmRsZXI8Rm9ybUVsZW1lbnRDb25zdHJhaW50PiA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IEZvcm1BY3Rpb24uSU5QVVRfVE9VQ0gsIHBheWxvYWQ6IHsgaWQ6IGV2ZW50LnRhcmdldC5pZCwgdmFsdWU6ICcnIH0gfSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgb25DaGFuZ2VIYW5kbGVyOiBSZWFjdC5DaGFuZ2VFdmVudEhhbmRsZXI8Rm9ybUVsZW1lbnRDb25zdHJhaW50PiA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBGb3JtQWN0aW9uLklOUFVUX0NIQU5HRSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICBpZDogZXZlbnQudGFyZ2V0LmlkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHsgZm9ybVN0YXRlLCBvbkNoYW5nZUhhbmRsZXIsIG9uVG91Y2hIYW5kbGVyLCBzZXRGb3JtU3RhdGUgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdXNlRm9ybTtcbiJdfQ==