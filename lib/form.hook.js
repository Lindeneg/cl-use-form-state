"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInput = getInput;
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

var _form = require("./form.validation");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var FormAction;

(function (FormAction) {
  FormAction["INPUT_CHANGE"] = "INPUT_CHANGE";
  FormAction["INPUT_TOUCH"] = "INPUT_TOUCH";
  FormAction["SET_FORM"] = "SET_FORM";
})(FormAction || (FormAction = {}));

/**
 * Get an object of type FormEntryState by just defining the input type, initial value and options.
 *
 * @param initialValue - initial value of the input entry.
 * @param options      - (optional) options for initial input state and validation
 * @returns Object of type FormEntryState
 */
function getInput(initialValue, options) {
  var parsedOptions = {
    isValid: false,
    isTouched: false,
    validators: [],
    connectedFields: (options === null || options === void 0 ? void 0 : options.connectFields) || []
  };

  if (typeof options !== 'undefined') {
    var keys = Object.keys(options);
    parsedOptions.isTouched = !!options.isTouched;
    parsedOptions.isValid = !!options.isValid;
    keys.forEach(function (key) {
      if (!['isValid', 'isTouched', 'connectedFields'].includes(key)) {
        parsedOptions.validators.push((0, _form.getValidator)(key, options[key]));
      }
    });
  }

  return _objectSpread(_objectSpread({}, parsedOptions), {}, {
    value: initialValue
  });
}
/**
 * Handle all connected fields tied to a certain input. This is useful for the following reason:
 *
 * If we have input A and input B and input B is dependent upon input A. Then we'd like to be able to
 * run the validation for input B each time the value of input A changes.
 *
 * @param state   - current FormState where the connected inputs can be found
 * @param targetId - Id of the owning input (input A in the example above)
 * @returns An object with entry keys and their updated object of type FormEntryState
 */


var handleConnectedFields = function handleConnectedFields(state, targetId) {
  try {
    var newInputState = _objectSpread({}, state.inputs); // find connected fields from the targetId


    newInputState[targetId].connectedFields.forEach(function (connectedFieldId) {
      // if the connected field exists
      if (typeof newInputState[connectedFieldId] !== 'undefined') {
        // then validate it given the specified state
        newInputState[connectedFieldId] = _objectSpread(_objectSpread({}, newInputState[connectedFieldId]), {}, {
          isValid: (0, _form.validate)(newInputState[connectedFieldId].value, newInputState[connectedFieldId].validators, state)
        });
      }
    });
    return newInputState;
  } catch (err) {
    process.env.NODE_ENV !== 'production' && console.error(err);
    return state.inputs;
  }
};
/**
 * Handle changes to FormState given an action associated with a payload.
 *
 * @param state Object with current FormState
 * @param action FormAction and FormPayload to handle
 * @returns Object with the updated FormState
 */


function formReducer(state, action) {
  var pl = action.payload;

  switch (action.type) {
    case FormAction.INPUT_CHANGE:
      // copy the current state, update the entry with the specified payload Id and validate it.
      var newState = _objectSpread(_objectSpread({}, state), {}, {
        inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
          value: pl.value,
          isValid: (0, _form.validate)(pl.value, state.inputs[pl.id].validators, state)
        })))
      }); // copy the inputs and validate connected fields given the now updated state.


      newState.inputs = _objectSpread(_objectSpread({}, newState.inputs), handleConnectedFields(_objectSpread({}, newState), pl.id)); // validate the entire form, if a single key fails, the whole form becomes invalid.

      var isValid = true;

      for (var _key in newState.inputs) {
        isValid = isValid && newState.inputs[_key].isValid;
      } // return the updated FormState


      return _objectSpread(_objectSpread({}, newState), {}, {
        inputs: _objectSpread({}, newState.inputs),
        isValid: isValid
      });

    case FormAction.INPUT_TOUCH:
      return _objectSpread(_objectSpread({}, state), {}, {
        inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
          isTouched: true
        })))
      });

    case FormAction.SET_FORM:
      if (typeof pl.state !== 'undefined') {
        return _objectSpread({}, pl.state);
      } else {
        return state;
      }

    default:
      return state;
  }
}
/**
 * React hook for managing the state of a form and its associated inputs.
 *
 * @param initialState - Object with initial FormState

 * @returns Object of UseForm type with specified properties and types.
 */


function useForm(initialState) {
  var _useReducer = (0, _react.useReducer)(formReducer, _objectSpread({}, initialState)),
      _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
      formState = _useReducer2[0],
      dispatch = _useReducer2[1];
  /**
   * Overwrite existing FormState by setting a new one.
   *
   * @param state Object with the new FormState
   */


  var setFormState = (0, _react.useCallback)(function (state) {
    dispatch({
      type: FormAction.SET_FORM,
      payload: {
        state: state,
        value: '',
        id: ''
      }
    });
  }, []);
  /**
   * Handles touch events. Can be used with prop 'onBlur', for example:
   *
   * \<input onBlur={onTouchHandler} /\>
   *
   */

  var onTouchHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_TOUCH,
      payload: {
        id: event.target.id,
        value: ''
      }
    });
  }, []);
  /**
   * Handles change events. Can be used with prop 'onChange', for example:
   *
   * \<input onChange={onChangeHandler} /\>
   *
   */

  var onChangeHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_CHANGE,
      payload: {
        id: event.target.id,
        value: event.target.value
      }
    });
  }, []);
  return {
    formState: formState,
    onChangeHandler: onChangeHandler,
    onTouchHandler: onTouchHandler,
    setFormState: setFormState
  };
}

var _default = useForm;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mb3JtLmhvb2sudHMiXSwibmFtZXMiOlsiRm9ybUFjdGlvbiIsImdldElucHV0IiwiaW5pdGlhbFZhbHVlIiwib3B0aW9ucyIsInBhcnNlZE9wdGlvbnMiLCJpc1ZhbGlkIiwiaXNUb3VjaGVkIiwidmFsaWRhdG9ycyIsImNvbm5lY3RlZEZpZWxkcyIsImNvbm5lY3RGaWVsZHMiLCJrZXlzIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicHVzaCIsInZhbHVlIiwiaGFuZGxlQ29ubmVjdGVkRmllbGRzIiwic3RhdGUiLCJ0YXJnZXRJZCIsIm5ld0lucHV0U3RhdGUiLCJpbnB1dHMiLCJjb25uZWN0ZWRGaWVsZElkIiwiZXJyIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwiZm9ybVJlZHVjZXIiLCJhY3Rpb24iLCJwbCIsInBheWxvYWQiLCJ0eXBlIiwiSU5QVVRfQ0hBTkdFIiwibmV3U3RhdGUiLCJpZCIsIklOUFVUX1RPVUNIIiwiU0VUX0ZPUk0iLCJ1c2VGb3JtIiwiaW5pdGlhbFN0YXRlIiwiZm9ybVN0YXRlIiwiZGlzcGF0Y2giLCJzZXRGb3JtU3RhdGUiLCJvblRvdWNoSGFuZGxlciIsImV2ZW50IiwidGFyZ2V0Iiwib25DaGFuZ2VIYW5kbGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBOzs7Ozs7SUFFS0EsVTs7V0FBQUEsVTtBQUFBQSxFQUFBQSxVO0FBQUFBLEVBQUFBLFU7QUFBQUEsRUFBQUEsVTtHQUFBQSxVLEtBQUFBLFU7O0FBa0VMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0MsUUFBVCxDQUNIQyxZQURHLEVBRUhDLE9BRkcsRUFHYztBQUNqQixNQUFNQyxhQUErQyxHQUFHO0FBQ3BEQyxJQUFBQSxPQUFPLEVBQUUsS0FEMkM7QUFFcERDLElBQUFBLFNBQVMsRUFBRSxLQUZ5QztBQUdwREMsSUFBQUEsVUFBVSxF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QUEsS0FBSyxFQUFFNkIsS0FBSyxDQUFDQyxNQUFOLENBQWE5QjtBQUZmO0FBRkosS0FBRCxDQUFSO0FBT0gsR0FSd0UsRUFRdEUsRUFSc0UsQ0FBekU7QUFVQSxTQUFPO0FBQUV5QixJQUFBQSxTQUFTLEVBQVRBLFNBQUY7QUFBYU0sSUFBQUEsZUFBZSxFQUFmQSxlQUFiO0FBQThCSCxJQUFBQSxjQUFjLEVBQWRBLGNBQTlCO0FBQThDRCxJQUFBQSxZQUFZLEVBQVpBO0FBQTlDLEdBQVA7QUFDSDs7ZUFFY0osTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZUNhbGxiYWNrLCBSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBWYWxpZGF0b3IsIFZhbGlkYXRpb25UeXBlLCBDdXN0b21WYWxpZGF0aW9uUnVsZSwgZ2V0VmFsaWRhdG9yLCB2YWxpZGF0ZSB9IGZyb20gJy4vZm9ybS52YWxpZGF0aW9uJztcblxuZW51bSBGb3JtQWN0aW9uIHtcbiAgICBJTlBVVF9DSEFOR0UgPSAnSU5QVVRfQ0hBTkdFJyxcbiAgICBJTlBVVF9UT1VDSCA9ICdJTlBVVF9UT1VDSCcsXG4gICAgU0VUX0ZPUk0gPSAnU0VUX0ZPUk0nXG59XG5cbmludGVyZmFjZSBGb3JtUGF5bG9hZCBleHRlbmRzIFBpY2s8Rm9ybUVudHJ5U3RhdGU8YW55PiwgJ3ZhbHVlJz4ge1xuICAgIHJlYWRvbmx5IGlkOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgc3RhdGU/OiBGb3JtU3RhdGU8YW55Pjtcbn1cblxudHlwZSBGb3JtRWxlbWVudENvbnN0cmFpbnQgPSBIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudCB8IEhUTUxTZWxlY3RFbGVtZW50IHwgSFRNTE9wdGlvbkVsZW1lbnQ7XG5cbnR5cGUgUmVkdWNlckFjdGlvbiA9IHsgdHlwZTogRm9ybUFjdGlvbjsgcGF5bG9hZDogRm9ybVBheWxvYWQgfTtcblxudHlwZSBHZXRJbnB1dE9wdGlvbnM8VCBleHRlbmRzIEZvcm1WYWx1ZVR5cGUsIFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50ID0gYW55PiA9IHtcbiAgICBba2V5OiBzdHJpbmddOiBUIHwgbnVtYmVyIHwgYm9vbGVhbiB8IEN1c3RvbVZhbGlkYXRpb25SdWxlPFQsIFM+IHwgc3RyaW5nW10gfCB1bmRlZmluZWQ7XG4gICAgbWluTGVuZ3RoPzogbnVtYmVyO1xuICAgIG1heExlbmd0aD86IG51bWJlcjtcbiAgICBtaW5WYWx1ZT86IG51bWJlcjtcbiAgICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgICBtaW5VcHBlcmNhc2VDaGFyYWN0ZXJzPzogbnVtYmVyO1xuICAgIG1heFVwcGVyY2FzZUNoYXJhY3RlcnM/OiBudW1iZXI7XG4gICAgbWluTnVtZXJpY2FsU3ltYm9scz86IG51bWJlcjtcbiAgICBtYXhOdW1lcmljYWxTeW1ib2xzPzogbnVtYmVyO1xuICAgIGlzUmVxdWlyZWQ/OiBib29sZWFuO1xuICAgIGlzVmFsaWQ/OiBib29sZWFuO1xuICAgIGlzVG91Y2hlZD86IGJvb2xlYW47XG4gICAgY3VzdG9tUnVsZT86IEN1c3RvbVZhbGlkYXRpb25SdWxlPFQsIFM+O1xuICAgIGNvbm5lY3RGaWVsZHM/OiBzdHJpbmdbXTtcbn07XG5cbi8qIFRoaXMgaXMgdGhlIGJhc2UgZm9yIGFueSBpbnB1dCBlbnRyeSBpbiBhICdmb3JtU3RhdGUnLiBJbiBvdGhlciB3b3Jkc1xuICAgYWxsIGlucHV0IGVudHJpZXMgd2lsbCBoYXZlIHRoZXNlIHByb3BlcnRpZXMgYXZhaWxhYmxlLiAqL1xudHlwZSBGb3JtRW50cnlTdGF0ZTxUIGV4dGVuZHMgRm9ybVZhbHVlVHlwZT4gPSB7XG4gICAgdmFsdWU6IFQ7XG4gICAgaXNWYWxpZDogYm9vbGVhbjtcbiAgICBpc1RvdWNoZWQ6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgdmFsaWRhdG9yczogVmFsaWRhdG9yW107XG4gICAgcmVhZG9ubHkgY29ubmVjdGVkRmllbGRzOiBzdHJpbmdbXTtcbn07XG5cbi8qIFRoZSB0eXBlIG9mIG9iamVjdCByZXR1cm5lZCBieSB1c2VGb3JtIHdoZW4gaW5pdGlhbGl6ZWQuICovXG50eXBlIFVzZUZvcm08UyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+ID0ge1xuICAgIGZvcm1TdGF0ZTogRm9ybVN0YXRlPFM+O1xuICAgIG9uVG91Y2hIYW5kbGVyOiBSZWFjdC5Gb2N1c0V2ZW50SGFuZGxlcjxGb3JtRWxlbWVudENvbnN0cmFpbnQ+O1xuICAgIG9uQ2hhbmdlSGFuZGxlcjogUmVhY3QuQ2hhbmdlRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD47XG4gICAgc2V0Rm9ybVN0YXRlOiAoc3RhdGU6IEZvcm1TdGF0ZTxTPikgPT4gdm9pZDtcbn07XG5cbi8vIFN1cHBvcnRlZCBpbnB1dCB2YWxlcy4gQ2FuIGJlIGV4dGVuZGVkIGlmIG5lZWQgYmUuXG5leHBvcnQgdHlwZSBGb3JtVmFsdWVUeXBlID0gc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IEZpbGU7XG5cbi8qIFByb3BlcnR5IG5hbWVzIGFuZCB0eXBlcyBvZiBpbnB1dHMsIGZvciBleGFtcGxlOlxuICAgeyBwYXNzd29yZDogc3RyaW5nOyBhZ2U6IG51bWJlcjsgaXNIYXBweTogYm9vbGVhbjsgfSAqL1xuZXhwb3J0IHR5cGUgRm9ybUVudHJ5Q29uc3RyYWludCA9IHsgW2tleTogc3RyaW5nXTogRm9ybVZhbHVlVHlwZSB9O1xuXG4vKiBUaGlzIGlzIHRoZSBiYXNlIGZvciB0aGUgZm9ybSBzdGF0ZSBhbmQgdGhlIHR5cGUgb2Ygb2JqZWN0IHRoYXQgaXMgcmV0dXJuZWRcbiAgIGJ5IHVzZUZvcm0oKS5mb3JtU3RhdGUuIFRodXMsICdmb3JtU3RhdGUnIHdpbGwgYWx3YXlzIGhhdmUgcHJvcGVydGllc1xuICAgJ2lucHV0cycgYW5kICdpc1ZhbGlkJyBhdmFpbGFibGUgd2hpbGUgdGhlIGlucHV0cyBwcm9wZXJ0eSwgaWYgbm9uLWVtcHR5LCBcbiAgIHdpbGwgaGF2ZSBrZXlzIHRoYXQgeWllbGRzIGFuIG9iamVjdCBvZiB0eXBlIEZvcm1FbnRyeVN0YXRlICovXG5leHBvcnQgdHlwZSBGb3JtU3RhdGU8VCBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+ID0ge1xuICAgIGlucHV0czogeyBbSyBpbiBrZXlvZiBUXTogRm9ybUVudHJ5U3RhdGU8VFtLXT4gfTtcbiAgICBpc1ZhbGlkOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGUgYnkganVzdCBkZWZpbmluZyB0aGUgaW5wdXQgdHlwZSwgaW5pdGlhbCB2YWx1ZSBhbmQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIC0gaW5pdGlhbCB2YWx1ZSBvZiB0aGUgaW5wdXQgZW50cnkuXG4gKiBAcGFyYW0gb3B0aW9ucyAgICAgIC0gKG9wdGlvbmFsKSBvcHRpb25zIGZvciBpbml0aWFsIGlucHV0IHN0YXRlIGFuZCB2YWxpZGF0aW9uXG4gKiBAcmV0dXJucyBPYmplY3Qgb2YgdHlwZSBGb3JtRW50cnlTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5wdXQ8VCBleHRlbmRzIEZvcm1WYWx1ZVR5cGUsIFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50ID0gYW55PihcbiAgICBpbml0aWFsVmFsdWU6IFQsXG4gICAgb3B0aW9ucz86IEdldElucHV0T3B0aW9uczxULCBTPlxuKTogRm9ybUVudHJ5U3RhdGU8VD4ge1xuICAgIGNvbnN0IHBhcnNlZE9wdGlvbnM6IE9taXQ8Rm9ybUVudHJ5U3RhdGU8VD4sICd2YWx1ZSc+ID0ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgaXNUb3VjaGVkOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdG9yczogW10sXG4gICAgICAgIGNvbm5lY3RlZEZpZWxkczogb3B0aW9ucz8uY29ubmVjdEZpZWxkcyB8fCBbXVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICAgIHBhcnNlZE9wdGlvbnMuaXNUb3VjaGVkID0gISFvcHRpb25zLmlzVG91Y2hlZDtcbiAgICAgICAgcGFyc2VkT3B0aW9ucy5pc1ZhbGlkID0gISFvcHRpb25zLmlzVmFsaWQ7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIVsnaXNWYWxpZCcsICdpc1RvdWNoZWQnLCAnY29ubmVjdGVkRmllbGRzJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMudmFsaWRhdG9ycy5wdXNoKGdldFZhbGlkYXRvcihrZXkgYXMgVmFsaWRhdGlvblR5cGUsIG9wdGlvbnNba2V5XSBhcyBUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXJzZWRPcHRpb25zLFxuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlXG4gICAgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgYWxsIGNvbm5lY3RlZCBmaWVsZHMgdGllZCB0byBhIGNlcnRhaW4gaW5wdXQuIFRoaXMgaXMgdXNlZnVsIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbjpcbiAqXG4gKiBJZiB3ZSBoYXZlIGlucHV0IEEgYW5kIGlucHV0IEIgYW5kIGlucHV0IEIgaXMgZGVwZW5kZW50IHVwb24gaW5wdXQgQS4gVGhlbiB3ZSdkIGxpa2UgdG8gYmUgYWJsZSB0b1xuICogcnVuIHRoZSB2YWxpZGF0aW9uIGZvciBpbnB1dCBCIGVhY2ggdGltZSB0aGUgdmFsdWUgb2YgaW5wdXQgQSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAgIC0gY3VycmVudCBGb3JtU3RhdGUgd2hlcmUgdGhlIGNvbm5lY3RlZCBpbnB1dHMgY2FuIGJlIGZvdW5kXG4gKiBAcGFyYW0gdGFyZ2V0SWQgLSBJZCBvZiB0aGUgb3duaW5nIGlucHV0IChpbnB1dCBBIGluIHRoZSBleGFtcGxlIGFib3ZlKVxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggZW50cnkga2V5cyBhbmQgdGhlaXIgdXBkYXRlZCBvYmplY3Qgb2YgdHlwZSBGb3JtRW50cnlTdGF0ZVxuICovXG5jb25zdCBoYW5kbGVDb25uZWN0ZWRGaWVsZHMgPSAoc3RhdGU6IEZvcm1TdGF0ZTxhbnk+LCB0YXJnZXRJZDogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBGb3JtRW50cnlTdGF0ZTxhbnk+IH0gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld0lucHV0U3RhdGUgPSB7IC4uLnN0YXRlLmlucHV0cyB9O1xuICAgICAgICAvLyBmaW5kIGNvbm5lY3RlZCBmaWVsZHMgZnJvbSB0aGUgdGFyZ2V0SWRcbiAgICAgICAgbmV3SW5wdXRTdGF0ZVt0YXJnZXRJZF0uY29ubmVjdGVkRmllbGRzLmZvckVhY2goKGNvbm5lY3RlZEZpZWxkSWQpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb25uZWN0ZWQgZmllbGQgZXhpc3RzXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlbiB2YWxpZGF0ZSBpdCBnaXZlbiB0aGUgc3BlY2lmaWVkIHN0YXRlXG4gICAgICAgICAgICAgICAgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXSxcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZDogdmFsaWRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnB1dFN0YXRlW2Nvbm5lY3RlZEZpZWxkSWRdLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXS52YWxpZGF0b3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3SW5wdXRTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHJldHVybiBzdGF0ZS5pbnB1dHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgY2hhbmdlcyB0byBGb3JtU3RhdGUgZ2l2ZW4gYW4gYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCBhIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHN0YXRlIE9iamVjdCB3aXRoIGN1cnJlbnQgRm9ybVN0YXRlXG4gKiBAcGFyYW0gYWN0aW9uIEZvcm1BY3Rpb24gYW5kIEZvcm1QYXlsb2FkIHRvIGhhbmRsZVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHVwZGF0ZWQgRm9ybVN0YXRlXG4gKi9cbmZ1bmN0aW9uIGZvcm1SZWR1Y2VyPFMgZXh0ZW5kcyBGb3JtU3RhdGU8YW55Pj4oc3RhdGU6IFMsIGFjdGlvbjogUmVkdWNlckFjdGlvbik6IFMge1xuICAgIGNvbnN0IHBsID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIEZvcm1BY3Rpb24uSU5QVVRfQ0hBTkdFOlxuICAgICAgICAgICAgLy8gY29weSB0aGUgY3VycmVudCBzdGF0ZSwgdXBkYXRlIHRoZSBlbnRyeSB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZCBJZCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZTogUyA9IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICBbcGwuaWRdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbnB1dHNbcGwuaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBsLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZDogdmFsaWRhdGUocGwudmFsdWUsIHN0YXRlLmlucHV0c1twbC5pZF0udmFsaWRhdG9ycywgc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY29weSB0aGUgaW5wdXRzIGFuZCB2YWxpZGF0ZSBjb25uZWN0ZWQgZmllbGRzIGdpdmVuIHRoZSBub3cgdXBkYXRlZCBzdGF0ZS5cbiAgICAgICAgICAgIG5ld1N0YXRlLmlucHV0cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5pbnB1dHMsXG4gICAgICAgICAgICAgICAgLi4uaGFuZGxlQ29ubmVjdGVkRmllbGRzKHsgLi4ubmV3U3RhdGUgfSwgcGwuaWQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gdmFsaWRhdGUgdGhlIGVudGlyZSBmb3JtLCBpZiBhIHNpbmdsZSBrZXkgZmFpbHMsIHRoZSB3aG9sZSBmb3JtIGJlY29tZXMgaW52YWxpZC5cbiAgICAgICAgICAgIGxldCBpc1ZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1N0YXRlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBpc1ZhbGlkICYmIG5ld1N0YXRlLmlucHV0c1trZXldLmlzVmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIHVwZGF0ZWQgRm9ybVN0YXRlXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5pbnB1dHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzVmFsaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgRm9ybUFjdGlvbi5JTlBVVF9UT1VDSDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgW3BsLmlkXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzW3BsLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBGb3JtQWN0aW9uLlNFVF9GT1JNOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbC5zdGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi4ocGwuc3RhdGUgYXMgUykgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZWFjdCBob29rIGZvciBtYW5hZ2luZyB0aGUgc3RhdGUgb2YgYSBmb3JtIGFuZCBpdHMgYXNzb2NpYXRlZCBpbnB1dHMuXG4gKlxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSAtIE9iamVjdCB3aXRoIGluaXRpYWwgRm9ybVN0YXRlXG5cbiAqIEByZXR1cm5zIE9iamVjdCBvZiBVc2VGb3JtIHR5cGUgd2l0aCBzcGVjaWZpZWQgcHJvcGVydGllcyBhbmQgdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHVzZUZvcm08UyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+KGluaXRpYWxTdGF0ZTogRm9ybVN0YXRlPFM+KTogVXNlRm9ybTxTPiB7XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcjxSZWR1Y2VyPEZvcm1TdGF0ZTxTPiwgUmVkdWNlckFjdGlvbj4+KGZvcm1SZWR1Y2VyLCB7XG4gICAgICAgIC4uLmluaXRpYWxTdGF0ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlIGV4aXN0aW5nIEZvcm1TdGF0ZSBieSBzZXR0aW5nIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBPYmplY3Qgd2l0aCB0aGUgbmV3IEZvcm1TdGF0ZVxuICAgICAqL1xuICAgIGNvbnN0IHNldEZvcm1TdGF0ZSA9IHVzZUNhbGxiYWNrKChzdGF0ZTogRm9ybVN0YXRlPFM+KTogdm9pZCA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogRm9ybUFjdGlvbi5TRVRfRk9STSwgcGF5bG9hZDogeyBzdGF0ZSwgdmFsdWU6ICcnLCBpZDogJycgfSB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRvdWNoIGV2ZW50cy4gQ2FuIGJlIHVzZWQgd2l0aCBwcm9wICdvbkJsdXInLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIFxcPGlucHV0IG9uQmx1cj17b25Ub3VjaEhhbmRsZXJ9IC9cXD5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IG9uVG91Y2hIYW5kbGVyOiBSZWFjdC5Gb2N1c0V2ZW50SGFuZGxlcjxGb3JtRWxlbWVudENvbnN0cmFpbnQ+ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogRm9ybUFjdGlvbi5JTlBVVF9UT1VDSCwgcGF5bG9hZDogeyBpZDogZXZlbnQudGFyZ2V0LmlkLCB2YWx1ZTogJycgfSB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNoYW5nZSBldmVudHMuIENhbiBiZSB1c2VkIHdpdGggcHJvcCAnb25DaGFuZ2UnLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIFxcPGlucHV0IG9uQ2hhbmdlPXtvbkNoYW5nZUhhbmRsZXJ9IC9cXD5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IG9uQ2hhbmdlSGFuZGxlcjogUmVhY3QuQ2hhbmdlRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD4gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogRm9ybUFjdGlvbi5JTlBVVF9DSEFOR0UsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LnRhcmdldC5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IGZvcm1TdGF0ZSwgb25DaGFuZ2VIYW5kbGVyLCBvblRvdWNoSGFuZGxlciwgc2V0Rm9ybVN0YXRlIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUZvcm07XG4iXX0=