"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInput = getInput;
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

var _form = require("./form.validation");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var FormAction;

(function (FormAction) {
  FormAction["INPUT_CHANGE"] = "INPUT_CHANGE";
  FormAction["INPUT_TOUCH"] = "INPUT_TOUCH";
  FormAction["SET_FORM"] = "SET_FORM";
})(FormAction || (FormAction = {}));

/**
 * Get an object of type FormEntryState by just defining the input type, initial value and options.
 *
 * @param initialValue - initial value of the input entry.
 * @param options      - (optional) options for initial input state and validation
 * @returns Object of type FormEntryState
 */
function getInput(initialValue, options) {
  var parsedOptions = {
    isValid: false,
    isTouched: false,
    validators: [],
    connectedFields: (options === null || options === void 0 ? void 0 : options.connectFields) || []
  };

  if (typeof options !== 'undefined') {
    var keys = Object.keys(options);
    parsedOptions.isTouched = !!options.isTouched;
    parsedOptions.isValid = !!options.isValid;
    keys.forEach(function (key) {
      if (!['isValid', 'isTouched', 'connectedFields'].includes(key)) {
        parsedOptions.validators.push((0, _form.getValidator)(key, options[key]));
      }
    });
  }

  return _objectSpread(_objectSpread({}, parsedOptions), {}, {
    value: initialValue
  });
}
/**
 * Handle all connected fields tied to a certain input. This is useful for the following reason:
 *
 * If we have input A and input B and input B is dependent upon input A. Then we'd like to be able to
 * run the validation for input B each time the value of input A changes.
 *
 * @param state   - current FormState where the connected inputs can be found
 * @param targetId - Id of the owning input (input A in the example above)
 * @returns An object with entry keys and their updated object of type FormEntryState
 */


var handleConnectedFields = function handleConnectedFields(state, targetId) {
  try {
    var newInputState = _objectSpread({}, state.inputs); // find connected fields from the targetId


    newInputState[targetId].connectedFields.forEach(function (connectedFieldId) {
      // if the connected field exists
      if (typeof newInputState[connectedFieldId] !== 'undefined') {
        // then validate it given the specified state
        newInputState[connectedFieldId] = _objectSpread(_objectSpread({}, newInputState[connectedFieldId]), {}, {
          isValid: (0, _form.validate)(newInputState[connectedFieldId].value, newInputState[connectedFieldId].validators, state)
        });
      }
    });
    return newInputState;
  } catch (err) {
    process.env.NODE_ENV !== 'production' && console.error(err);
    return state.inputs;
  }
};
/**
 * Handle changes to FormState given an action associated with a payload.
 *
 * @param state Object with current FormState
 * @param action FormAction and FormPayload to handle
 * @returns Object with the updated FormState
 */


function formReducer(state, action) {
  var pl = action.payload;

  switch (action.type) {
    case FormAction.INPUT_CHANGE:
      try {
        // copy the current state, update the entry with the specified payload Id and validate it.
        var newState = _objectSpread(_objectSpread({}, state), {}, {
          inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
            value: pl.value,
            isValid: (0, _form.validate)(pl.value, state.inputs[pl.id].validators, state)
          })))
        }); // copy the inputs and validate connected fields given the now updated state.


        newState.inputs = _objectSpread(_objectSpread({}, newState.inputs), handleConnectedFields(newState, pl.id)); // return the updated FormState

        return _objectSpread(_objectSpread({}, newState), {}, {
          inputs: _objectSpread({}, newState.inputs),
          isValid: (0, _form.validateState)(newState)
        });
      } catch (err) {
        console.error("use-form-state cannot recognize input-id '".concat(pl.id, "'. Please make sure that all form input names are tied to a form element, such as <input id='{ID}' />."));
        break;
      }

    case FormAction.INPUT_TOUCH:
      try {
        return _objectSpread(_objectSpread({}, state), {}, {
          inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
            isTouched: true
          })))
        });
      } catch (err) {
        console.error("use-form-state cannot recognize input-id '".concat(pl.id, "'. Please make sure that all form input names are tied to a form element, such as <input id='{ID}' />."));
        break;
      }

    case FormAction.SET_FORM:
      if (typeof pl.state !== 'undefined') {
        return _objectSpread({}, pl.state);
      } else {
        return state;
      }

    default:
      break;
  }

  return state;
}

function getState(initialState) {
  var state;

  if (Object.keys(initialState).length === 2 && typeof initialState.inputs !== 'undefined' && typeof initialState.isValid !== 'undefined') {
    state = _objectSpread({}, initialState);
  } else {
    state = {
      inputs: _objectSpread({}, initialState),
      isValid: false
    };
    state.isValid = (0, _form.validateState)(state);
  }

  return state;
}
/**
 * React hook for managing the state of a form and its associated inputs.
 *
 * @param initialState - Object with initial FormState or initial Inputs

 * @returns Object of UseForm type with specified properties and types.
 */


function useForm(initialState) {
  var _useReducer = (0, _react.useReducer)(formReducer, _objectSpread({}, getState(initialState))),
      _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
      formState = _useReducer2[0],
      dispatch = _useReducer2[1];

  var setFormState = (0, _react.useCallback)(function (state) {
    dispatch({
      type: FormAction.SET_FORM,
      payload: {
        state: _objectSpread({}, getState(state)),
        value: '',
        id: ''
      }
    });
  }, []);
  var onTouchHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_TOUCH,
      payload: {
        id: event.target.id,
        value: ''
      }
    });
  }, []);
  var onChangeHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_CHANGE,
      payload: {
        id: event.target.id,
        value: event.target.value
      }
    });
  }, []);
  return {
    formState: formState,
    onChangeHandler: onChangeHandler,
    onTouchHandler: onTouchHandler,
    setFormState: setFormState
  };
}

var _default = useForm;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mb3JtLmhvb2sudHMiXSwibmFtZXMiOlsiRm9ybUFjdGlvbiIsImdldElucHV0IiwiaW5pdGlhbFZhbHVlIiwib3B0aW9ucyIsInBhcnNlZE9wdGlvbnMiLCJpc1ZhbGlkIiwiaXNUb3VjaGVkIiwidmFsaWRhdG9ycyIsImNvbm5lY3RlZEZpZWxkcyIsImNvbm5lY3RGaWVsZHMiLCJrZXlzIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicHVzaCIsInZhbHVlIiwiaGFuZGxlQ29ubmVjdGVkRmllbGRzIiwic3RhdGUiLCJ0YXJnZXRJZCIsIm5ld0lucHV0U3RhdGUiLCJpbnB1dHMiLCJjb25uZWN0ZWRGaWVsZElkIiwiZXJyIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwiZm9ybVJlZHVjZXIiLCJhY3Rpb24iLCJwbCIsInBheWxvYWQiLCJ0eXBlIiwiSU5QVVRfQ0hBTkdFIiwibmV3U3RhdGUiLCJpZCIsIklOUFVUX1RPVUNIIiwiU0VUX0ZPUk0iLCJnZXRTdGF0ZSIsImluaXRpYWxTdGF0ZSIsImxlbmd0aCIsInVzZUZvcm0iLCJmb3JtU3RhdGUiLCJkaXNwYXRjaCIsInNldEZvcm1TdGF0ZSIsIm9uVG91Y2hIYW5kbGVyIiwiZXZlbnQiLCJ0YXJnZXQiLCJvbkNoYW5nZUhhbmRsZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7Ozs7OztJQVNLQSxVOztXQUFBQSxVO0FBQUFBLEVBQUFBLFU7QUFBQUEsRUFBQUEsVTtBQUFBQSxFQUFBQSxVO0dBQUFBLFUsS0FBQUEsVTs7QUFvR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQyxRQUFULENBQ0hDLFlBREcsRUFFSEMsT0FGRyxFQUdjO0FBQ2pCLE1BQU1DLGFBQStDLEdBQUc7QUFDcERDLElBQUFBLE9BQU8sRUFBRSxLQUQyQztBQUVwREMsSUFBQUEsU0FBUyxFQUFFLEtBRnlD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SUEsTUFBTVUsY0FBOEQsR0FBRyx3QkFBWSxVQUFDQyxLQUFELEVBQVc7QUFDMUZILElBQUFBLFFBQVEsQ0FBQztBQUFFWCxNQUFBQSxJQUFJLEVBQUVqQyxVQUFVLENBQUNxQyxXQUFuQjtBQUFnQ0wsTUFBQUEsT0FBTyxFQUFFO0FBQUVJLFFBQUFBLEVBQUUsRUFBRVcsS0FBSyxDQUFDQyxNQUFOLENBQWFaLEVBQW5CO0FBQXVCcEIsUUFBQUEsS0FBSyxFQUFFO0FBQTlCO0FBQXpDLEtBQUQsQ0FBUjtBQUNILEdBRnNFLEVBRXBFLEVBRm9FLENBQXZFO0FBSUEsTUFBTWlDLGVBQWdFLEdBQUcsd0JBQVksVUFBQ0YsS0FBRCxFQUFXO0FBQzVGSCxJQUFBQSxRQUFRLENBQUM7QUFDTFgsTUFBQUEsSUFBSSxFQUFFakMsVUFBVSxDQUFDa0MsWUFEWjtBQUVMRixNQUFBQSxPQUFPLEVBQUU7QUFDTEksUUFBQUEsRUFBRSxFQUFFVyxLQUFLLENBQUNDLE1BQU4sQ0FBYVosRUFEWjtBQUVMcEIsUUFBQUEsS0FBSyxFQUFFK0IsS0FBSyxDQUFDQyxNQUFOLENBQWFoQztBQUZmO0FBRkosS0FBRCxDQUFSO0FBT0gsR0FSd0UsRUFRdEUsRUFSc0UsQ0FBekU7QUFVQSxTQUFPO0FBQUUyQixJQUFBQSxTQUFTLEVBQVRBLFNBQUY7QUFBYU0sSUFBQUEsZUFBZSxFQUFmQSxlQUFiO0FBQThCSCxJQUFBQSxjQUFjLEVBQWRBLGNBQTlCO0FBQThDRCxJQUFBQSxZQUFZLEVBQVpBO0FBQTlDLEdBQVA7QUFDSDs7ZUFFY0gsTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZUNhbGxiYWNrLCBSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge1xuICAgIFZhbGlkYXRvcixcbiAgICBWYWxpZGF0aW9uVHlwZSxcbiAgICBDdXN0b21WYWxpZGF0aW9uUnVsZSxcbiAgICBnZXRWYWxpZGF0b3IsXG4gICAgdmFsaWRhdGUsXG4gICAgdmFsaWRhdGVTdGF0ZVxufSBmcm9tICcuL2Zvcm0udmFsaWRhdGlvbic7XG5cbmVudW0gRm9ybUFjdGlvbiB7XG4gICAgSU5QVVRfQ0hBTkdFID0gJ0lOUFVUX0NIQU5HRScsXG4gICAgSU5QVVRfVE9VQ0ggPSAnSU5QVVRfVE9VQ0gnLFxuICAgIFNFVF9GT1JNID0gJ1NFVF9GT1JNJ1xufVxuXG5pbnRlcmZhY2UgRm9ybVBheWxvYWQgZXh0ZW5kcyBQaWNrPEZvcm1FbnRyeVN0YXRlPGFueT4sICd2YWx1ZSc+IHtcbiAgICByZWFkb25seSBpZDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHN0YXRlPzogRm9ybVN0YXRlPGFueT47XG59XG5cbnR5cGUgRm9ybUVsZW1lbnRDb25zdHJhaW50ID0gSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQgfCBIVE1MU2VsZWN0RWxlbWVudCB8IEhUTUxPcHRpb25FbGVtZW50O1xuXG50eXBlIFJlZHVjZXJBY3Rpb24gPSB7IHR5cGU6IEZvcm1BY3Rpb247IHBheWxvYWQ6IEZvcm1QYXlsb2FkIH07XG5cbi8qIFRoaXMgaXMgdGhlIGJhc2UgZm9yIGFueSBpbnB1dCBlbnRyeSBpbiBhICdmb3JtU3RhdGUnLiBJbiBvdGhlciB3b3Jkc1xuICAgYWxsIGlucHV0IGVudHJpZXMgd2lsbCBoYXZlIHRoZXNlIHByb3BlcnRpZXMgYXZhaWxhYmxlLiAqL1xudHlwZSBGb3JtRW50cnlTdGF0ZTxUIGV4dGVuZHMgRm9ybVZhbHVlVHlwZT4gPSB7XG4gICAgdmFsdWU6IFQ7XG4gICAgaXNWYWxpZDogYm9vbGVhbjtcbiAgICBpc1RvdWNoZWQ6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgdmFsaWRhdG9yczogVmFsaWRhdG9yW107XG4gICAgcmVhZG9ubHkgY29ubmVjdGVkRmllbGRzOiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCB0eXBlIEdldElucHV0T3B0aW9uczxUIGV4dGVuZHMgRm9ybVZhbHVlVHlwZSwgUyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQgPSBhbnk+ID0ge1xuICAgIFtrZXk6IHN0cmluZ106IFQgfCBudW1iZXIgfCBib29sZWFuIHwgQ3VzdG9tVmFsaWRhdGlvblJ1bGU8VCwgUz4gfCBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcbiAgICBtaW5MZW5ndGg/OiBudW1iZXI7XG4gICAgbWF4TGVuZ3RoPzogbnVtYmVyO1xuICAgIG1pblZhbHVlPzogbnVtYmVyO1xuICAgIG1heFZhbHVlPzogbnVtYmVyO1xuICAgIG1pblVwcGVyY2FzZUNoYXJhY3RlcnM/OiBudW1iZXI7XG4gICAgbWF4VXBwZXJjYXNlQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtaW5OdW1lcmljYWxTeW1ib2xzPzogbnVtYmVyO1xuICAgIG1heE51bWVyaWNhbFN5bWJvbHM/OiBudW1iZXI7XG4gICAgaXNSZXF1aXJlZD86IGJvb2xlYW47XG4gICAgaXNWYWxpZD86IGJvb2xlYW47XG4gICAgaXNUb3VjaGVkPzogYm9vbGVhbjtcbiAgICBjdXN0b21SdWxlPzogQ3VzdG9tVmFsaWRhdGlvblJ1bGU8VCwgUz47XG4gICAgY29ubmVjdEZpZWxkcz86IHN0cmluZ1tdO1xufTtcblxuLyogVGhlIHR5cGUgb2Ygb2JqZWN0IHJldHVybmVkIGJ5IHVzZUZvcm0gd2hlbiBpbml0aWFsaXplZC4gKi9cbmV4cG9ydCB0eXBlIFVzZUZvcm08UyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+ID0ge1xuICAgIC8qKlxuICAgICAqIGZvcm1TdGF0ZScgd2lsbCBhbHdheXMgaGF2ZSBwcm9wZXJ0aWVzICdpbnB1dHMnIGFuZCAnaXNWYWxpZCdcbiAgICAgKiBhdmFpbGFibGUgd2hpbGUgdGhlICdpbnB1dHMnIHByb3BlcnR5LCBpZiBub24tZW1wdHksIHdpbGxcbiAgICAgKiBoYXZlIGtleXMgdGhhdCB5aWVsZHMgYW4gb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGVcbiAgICAgKi9cbiAgICBmb3JtU3RhdGU6IEZvcm1TdGF0ZTxTPjtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdG91Y2ggZXZlbnRzLiBDYW4gYmUgdXNlZCB3aXRoIHByb3AgJ29uQmx1cicsIGZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogXFw8aW5wdXQgb25CbHVyPXtvblRvdWNoSGFuZGxlcn0gL1xcPlxuICAgICAqXG4gICAgICovXG4gICAgb25Ub3VjaEhhbmRsZXI6IFJlYWN0LkZvY3VzRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD47XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNoYW5nZSBldmVudHMuIENhbiBiZSB1c2VkIHdpdGggcHJvcCAnb25DaGFuZ2UnLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIFxcPGlucHV0IG9uQ2hhbmdlPXtvbkNoYW5nZUhhbmRsZXJ9IC9cXD5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2hhbmdlSGFuZGxlcjogUmVhY3QuQ2hhbmdlRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD47XG5cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgZXhpc3RpbmcgaW5wdXRzIGJ5IHNldHRpbmcgbmV3IG9uZXM6XG4gICAgICpcbiAgICAgKiBzZXRGb3JtU3RhdGUoe1xuICAgICAqICAgICAuLi5uZXdJbnB1dHNcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogT3IgYWRkIHRvIGN1cnJlbnQgaW5wdXRzOlxuICAgICAqXG4gICAgICogc2V0Rm9ybVN0YXRlKHtcbiAgICAgKiAgICAgLi4uZm9ybVN0YXRlLmlucHV0cyxcbiAgICAgKiAgICAgLi4ubmV3SW5wdXRzXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBPYmplY3Qgd2l0aCB0aGUgbmV3IEZvcm1TdGF0ZVxuICAgICAqL1xuICAgIHNldEZvcm1TdGF0ZTogKHN0YXRlOiBGb3JtU3RhdGU8Uz4gfCBJbnB1dHM8Uz4pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgdHlwZSBJbnB1dHM8VCBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+ID0geyBbSyBpbiBrZXlvZiBUXTogRm9ybUVudHJ5U3RhdGU8VFtLXT4gfTtcblxuLy8gU3VwcG9ydGVkIGlucHV0IHZhbGVzLiBDYW4gYmUgZXh0ZW5kZWQgaWYgbmVlZCBiZS5cbmV4cG9ydCB0eXBlIEZvcm1WYWx1ZVR5cGUgPSBzdHJpbmcgfCBzdHJpbmdbXSB8IG51bWJlciB8IGJvb2xlYW4gfCBGaWxlO1xuXG4vKiBQcm9wZXJ0eSBuYW1lcyBhbmQgdHlwZXMgb2YgaW5wdXRzLCBmb3IgZXhhbXBsZTpcbiAgIHsgcGFzc3dvcmQ6IHN0cmluZzsgYWdlOiBudW1iZXI7IGlzSGFwcHk6IGJvb2xlYW47IH0gKi9cbmV4cG9ydCB0eXBlIEZvcm1FbnRyeUNvbnN0cmFpbnQgPSB7IFtrZXk6IHN0cmluZ106IEZvcm1WYWx1ZVR5cGUgfTtcblxuZXhwb3J0IHR5cGUgRm9ybVN0YXRlPFQgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50PiA9IHtcbiAgICBpbnB1dHM6IElucHV0czxUPjtcbiAgICBpc1ZhbGlkOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGUgYnkganVzdCBkZWZpbmluZyB0aGUgaW5wdXQgdHlwZSwgaW5pdGlhbCB2YWx1ZSBhbmQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIC0gaW5pdGlhbCB2YWx1ZSBvZiB0aGUgaW5wdXQgZW50cnkuXG4gKiBAcGFyYW0gb3B0aW9ucyAgICAgIC0gKG9wdGlvbmFsKSBvcHRpb25zIGZvciBpbml0aWFsIGlucHV0IHN0YXRlIGFuZCB2YWxpZGF0aW9uXG4gKiBAcmV0dXJucyBPYmplY3Qgb2YgdHlwZSBGb3JtRW50cnlTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5wdXQ8VCBleHRlbmRzIEZvcm1WYWx1ZVR5cGUsIFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50ID0gYW55PihcbiAgICBpbml0aWFsVmFsdWU6IFQsXG4gICAgb3B0aW9ucz86IEdldElucHV0T3B0aW9uczxULCBTPlxuKTogRm9ybUVudHJ5U3RhdGU8VD4ge1xuICAgIGNvbnN0IHBhcnNlZE9wdGlvbnM6IE9taXQ8Rm9ybUVudHJ5U3RhdGU8VD4sICd2YWx1ZSc+ID0ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgaXNUb3VjaGVkOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdG9yczogW10sXG4gICAgICAgIGNvbm5lY3RlZEZpZWxkczogb3B0aW9ucz8uY29ubmVjdEZpZWxkcyB8fCBbXVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICAgIHBhcnNlZE9wdGlvbnMuaXNUb3VjaGVkID0gISFvcHRpb25zLmlzVG91Y2hlZDtcbiAgICAgICAgcGFyc2VkT3B0aW9ucy5pc1ZhbGlkID0gISFvcHRpb25zLmlzVmFsaWQ7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIVsnaXNWYWxpZCcsICdpc1RvdWNoZWQnLCAnY29ubmVjdGVkRmllbGRzJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMudmFsaWRhdG9ycy5wdXNoKGdldFZhbGlkYXRvcihrZXkgYXMgVmFsaWRhdGlvblR5cGUsIG9wdGlvbnNba2V5XSBhcyBUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXJzZWRPcHRpb25zLFxuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlXG4gICAgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgYWxsIGNvbm5lY3RlZCBmaWVsZHMgdGllZCB0byBhIGNlcnRhaW4gaW5wdXQuIFRoaXMgaXMgdXNlZnVsIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbjpcbiAqXG4gKiBJZiB3ZSBoYXZlIGlucHV0IEEgYW5kIGlucHV0IEIgYW5kIGlucHV0IEIgaXMgZGVwZW5kZW50IHVwb24gaW5wdXQgQS4gVGhlbiB3ZSdkIGxpa2UgdG8gYmUgYWJsZSB0b1xuICogcnVuIHRoZSB2YWxpZGF0aW9uIGZvciBpbnB1dCBCIGVhY2ggdGltZSB0aGUgdmFsdWUgb2YgaW5wdXQgQSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAgIC0gY3VycmVudCBGb3JtU3RhdGUgd2hlcmUgdGhlIGNvbm5lY3RlZCBpbnB1dHMgY2FuIGJlIGZvdW5kXG4gKiBAcGFyYW0gdGFyZ2V0SWQgLSBJZCBvZiB0aGUgb3duaW5nIGlucHV0IChpbnB1dCBBIGluIHRoZSBleGFtcGxlIGFib3ZlKVxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggZW50cnkga2V5cyBhbmQgdGhlaXIgdXBkYXRlZCBvYmplY3Qgb2YgdHlwZSBGb3JtRW50cnlTdGF0ZVxuICovXG5jb25zdCBoYW5kbGVDb25uZWN0ZWRGaWVsZHMgPSAoc3RhdGU6IEZvcm1TdGF0ZTxhbnk+LCB0YXJnZXRJZDogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBGb3JtRW50cnlTdGF0ZTxhbnk+IH0gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld0lucHV0U3RhdGUgPSB7IC4uLnN0YXRlLmlucHV0cyB9O1xuICAgICAgICAvLyBmaW5kIGNvbm5lY3RlZCBmaWVsZHMgZnJvbSB0aGUgdGFyZ2V0SWRcbiAgICAgICAgbmV3SW5wdXRTdGF0ZVt0YXJnZXRJZF0uY29ubmVjdGVkRmllbGRzLmZvckVhY2goKGNvbm5lY3RlZEZpZWxkSWQpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb25uZWN0ZWQgZmllbGQgZXhpc3RzXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlbiB2YWxpZGF0ZSBpdCBnaXZlbiB0aGUgc3BlY2lmaWVkIHN0YXRlXG4gICAgICAgICAgICAgICAgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXSxcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZDogdmFsaWRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnB1dFN0YXRlW2Nvbm5lY3RlZEZpZWxkSWRdLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXS52YWxpZGF0b3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3SW5wdXRTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHJldHVybiBzdGF0ZS5pbnB1dHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgY2hhbmdlcyB0byBGb3JtU3RhdGUgZ2l2ZW4gYW4gYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCBhIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHN0YXRlIE9iamVjdCB3aXRoIGN1cnJlbnQgRm9ybVN0YXRlXG4gKiBAcGFyYW0gYWN0aW9uIEZvcm1BY3Rpb24gYW5kIEZvcm1QYXlsb2FkIHRvIGhhbmRsZVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHVwZGF0ZWQgRm9ybVN0YXRlXG4gKi9cbmZ1bmN0aW9uIGZvcm1SZWR1Y2VyPFMgZXh0ZW5kcyBGb3JtU3RhdGU8YW55Pj4oc3RhdGU6IFMsIGFjdGlvbjogUmVkdWNlckFjdGlvbik6IFMge1xuICAgIGNvbnN0IHBsID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIEZvcm1BY3Rpb24uSU5QVVRfQ0hBTkdFOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSBjdXJyZW50IHN0YXRlLCB1cGRhdGUgdGhlIGVudHJ5IHdpdGggdGhlIHNwZWNpZmllZCBwYXlsb2FkIElkIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTdGF0ZTogUyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3BsLmlkXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmlucHV0c1twbC5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBsLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkYXRlKHBsLnZhbHVlLCBzdGF0ZS5pbnB1dHNbcGwuaWRdLnZhbGlkYXRvcnMsIHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSBpbnB1dHMgYW5kIHZhbGlkYXRlIGNvbm5lY3RlZCBmaWVsZHMgZ2l2ZW4gdGhlIG5vdyB1cGRhdGVkIHN0YXRlLlxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLmlucHV0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAuLi5oYW5kbGVDb25uZWN0ZWRGaWVsZHMobmV3U3RhdGUsIHBsLmlkKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSB1cGRhdGVkIEZvcm1TdGF0ZVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLmlucHV0c1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiB2YWxpZGF0ZVN0YXRlKG5ld1N0YXRlKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgdXNlLWZvcm0tc3RhdGUgY2Fubm90IHJlY29nbml6ZSBpbnB1dC1pZCAnJHtwbC5pZH0nLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgYWxsIGZvcm0gaW5wdXQgbmFtZXMgYXJlIHRpZWQgdG8gYSBmb3JtIGVsZW1lbnQsIHN1Y2ggYXMgPGlucHV0IGlkPSd7SUR9JyAvPi5gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBGb3JtQWN0aW9uLklOUFVUX1RPVUNIOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbnB1dHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbcGwuaWRdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzW3BsLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgdXNlLWZvcm0tc3RhdGUgY2Fubm90IHJlY29nbml6ZSBpbnB1dC1pZCAnJHtwbC5pZH0nLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgYWxsIGZvcm0gaW5wdXQgbmFtZXMgYXJlIHRpZWQgdG8gYSBmb3JtIGVsZW1lbnQsIHN1Y2ggYXMgPGlucHV0IGlkPSd7SUR9JyAvPi5gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBGb3JtQWN0aW9uLlNFVF9GT1JNOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbC5zdGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi4ocGwuc3RhdGUgYXMgUykgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGU8UyBleHRlbmRzIEZvcm1FbnRyeUNvbnN0cmFpbnQ+KGluaXRpYWxTdGF0ZTogRm9ybVN0YXRlPFM+IHwgSW5wdXRzPFM+KTogRm9ybVN0YXRlPFM+IHtcbiAgICBsZXQgc3RhdGU6IEZvcm1TdGF0ZTxTPjtcbiAgICBpZiAoXG4gICAgICAgIE9iamVjdC5rZXlzKGluaXRpYWxTdGF0ZSkubGVuZ3RoID09PSAyICYmXG4gICAgICAgIHR5cGVvZiBpbml0aWFsU3RhdGUuaW5wdXRzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgaW5pdGlhbFN0YXRlLmlzVmFsaWQgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICAgIHN0YXRlID0geyAuLi4oaW5pdGlhbFN0YXRlIGFzIEZvcm1TdGF0ZTxTPikgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGlucHV0czogeyAuLi4oaW5pdGlhbFN0YXRlIGFzIElucHV0czxTPikgfSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlLmlzVmFsaWQgPSB2YWxpZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIFJlYWN0IGhvb2sgZm9yIG1hbmFnaW5nIHRoZSBzdGF0ZSBvZiBhIGZvcm0gYW5kIGl0cyBhc3NvY2lhdGVkIGlucHV0cy5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIC0gT2JqZWN0IHdpdGggaW5pdGlhbCBGb3JtU3RhdGUgb3IgaW5pdGlhbCBJbnB1dHNcblxuICogQHJldHVybnMgT2JqZWN0IG9mIFVzZUZvcm0gdHlwZSB3aXRoIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGFuZCB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gdXNlRm9ybTxTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4oaW5pdGlhbFN0YXRlOiBGb3JtU3RhdGU8Uz4gfCBJbnB1dHM8Uz4pOiBVc2VGb3JtPFM+IHtcbiAgICBjb25zdCBbZm9ybVN0YXRlLCBkaXNwYXRjaF0gPSB1c2VSZWR1Y2VyPFJlZHVjZXI8Rm9ybVN0YXRlPFM+LCBSZWR1Y2VyQWN0aW9uPj4oZm9ybVJlZHVjZXIsIHtcbiAgICAgICAgLi4uZ2V0U3RhdGUoaW5pdGlhbFN0YXRlKVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2V0Rm9ybVN0YXRlID0gdXNlQ2FsbGJhY2soKHN0YXRlOiBGb3JtU3RhdGU8Uz4gfCBJbnB1dHM8Uz4pOiB2b2lkID0+IHtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiBGb3JtQWN0aW9uLlNFVF9GT1JNLCBwYXlsb2FkOiB7IHN0YXRlOiB7IC4uLmdldFN0YXRlKHN0YXRlKSB9LCB2YWx1ZTogJycsIGlkOiAnJyB9IH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uVG91Y2hIYW5kbGVyOiBSZWFjdC5Gb2N1c0V2ZW50SGFuZGxlcjxGb3JtRWxlbWVudENvbnN0cmFpbnQ+ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogRm9ybUFjdGlvbi5JTlBVVF9UT1VDSCwgcGF5bG9hZDogeyBpZDogZXZlbnQudGFyZ2V0LmlkLCB2YWx1ZTogJycgfSB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBvbkNoYW5nZUhhbmRsZXI6IFJlYWN0LkNoYW5nZUV2ZW50SGFuZGxlcjxGb3JtRWxlbWVudENvbnN0cmFpbnQ+ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IEZvcm1BY3Rpb24uSU5QVVRfQ0hBTkdFLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGlkOiBldmVudC50YXJnZXQuaWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBmb3JtU3RhdGUsIG9uQ2hhbmdlSGFuZGxlciwgb25Ub3VjaEhhbmRsZXIsIHNldEZvcm1TdGF0ZSB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB1c2VGb3JtO1xuIl19