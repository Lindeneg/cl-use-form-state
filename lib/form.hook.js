"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInput = getInput;
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

var _form = require("./form.validation");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var FormAction;

(function (FormAction) {
  FormAction["INPUT_CHANGE"] = "INPUT_CHANGE";
  FormAction["INPUT_TOUCH"] = "INPUT_TOUCH";
  FormAction["SET_FORM"] = "SET_FORM";
})(FormAction || (FormAction = {}));

/**
 * Get an object of type FormEntryState by just defining the input type, initial value and options.
 *
 * @param initialValue - initial value of the input entry.
 * @param options      - (optional) options for initial input state and validation
 * @returns Object of type FormEntryState
 */
function getInput(initialValue, options) {
  var parsedOptions = {
    isValid: false,
    isTouched: false,
    validators: [],
    connectedFields: (options === null || options === void 0 ? void 0 : options.connectFields) || []
  };

  if (typeof options !== 'undefined') {
    var keys = Object.keys(options);
    parsedOptions.isTouched = !!options.isTouched;
    parsedOptions.isValid = !!options.isValid;
    keys.forEach(function (key) {
      if (!['isValid', 'isTouched', 'connectedFields'].includes(key)) {
        parsedOptions.validators.push((0, _form.getValidator)(key, options[key]));
      }
    });
  }

  return _objectSpread(_objectSpread({}, parsedOptions), {}, {
    value: initialValue
  });
}
/**
 * Handle all connected fields tied to a certain input. This is useful for the following reason:
 *
 * If we have input A and input B and input B is dependent upon input A. Then we'd like to be able to
 * run the validation for input B each time the value of input A changes.
 *
 * @param state   - current FormState where the connected inputs can be found
 * @param targetId - Id of the owning input (input A in the example above)
 * @returns An object with entry keys and their updated object of type FormEntryState
 */


var handleConnectedFields = function handleConnectedFields(state, targetId) {
  try {
    var newInputState = _objectSpread({}, state.inputs); // find connected fields from the targetId


    newInputState[targetId].connectedFields.forEach(function (connectedFieldId) {
      // if the connected field exists
      if (typeof newInputState[connectedFieldId] !== 'undefined') {
        // then validate it given the specified state
        newInputState[connectedFieldId] = _objectSpread(_objectSpread({}, newInputState[connectedFieldId]), {}, {
          isValid: (0, _form.validate)(newInputState[connectedFieldId].value, newInputState[connectedFieldId].validators, state)
        });
      }
    });
    return newInputState;
  } catch (err) {
    process.env.NODE_ENV !== 'production' && console.error(err);
    return state.inputs;
  }
};
/**
 * Handle changes to FormState given an action associated with a payload.
 *
 * @param state Object with current FormState
 * @param action FormAction and FormPayload to handle
 * @returns Object with the updated FormState
 */


function formReducer(state, action) {
  var pl = action.payload;

  switch (action.type) {
    case FormAction.INPUT_CHANGE:
      // copy the current state, update the entry with the specified payload Id and validate it.
      var newState = _objectSpread(_objectSpread({}, state), {}, {
        inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
          value: pl.value,
          isValid: (0, _form.validate)(pl.value, state.inputs[pl.id].validators, state)
        })))
      }); // copy the inputs and validate connected fields given the now updated state.


      newState.inputs = _objectSpread(_objectSpread({}, newState.inputs), handleConnectedFields(newState, pl.id)); // return the updated FormState

      return _objectSpread(_objectSpread({}, newState), {}, {
        inputs: _objectSpread({}, newState.inputs),
        isValid: (0, _form.validateState)(newState)
      });

    case FormAction.INPUT_TOUCH:
      return _objectSpread(_objectSpread({}, state), {}, {
        inputs: _objectSpread(_objectSpread({}, state.inputs), {}, (0, _defineProperty2["default"])({}, pl.id, _objectSpread(_objectSpread({}, state.inputs[pl.id]), {}, {
          isTouched: true
        })))
      });

    case FormAction.SET_FORM:
      if (typeof pl.state !== 'undefined') {
        return _objectSpread({}, pl.state);
      } else {
        return state;
      }

    default:
      return state;
  }
}

function getState(initialState) {
  var state;

  if (Object.keys(initialState).length === 2 && typeof initialState.inputs !== 'undefined' && typeof initialState.isValid !== 'undefined') {
    state = _objectSpread({}, initialState);
  } else {
    state = {
      inputs: _objectSpread({}, initialState),
      isValid: false
    };
    state.isValid = (0, _form.validateState)(state);
  }

  return state;
}

/**
 * React hook for managing the state of a form and its associated inputs.
 *
 * @param initialState - Object with initial FormState or initial Inputs

 * @returns Object of UseForm type with specified properties and types.
 */
function useForm(initialState) {
  var _useReducer = (0, _react.useReducer)(formReducer, _objectSpread({}, getState(initialState))),
      _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
      formState = _useReducer2[0],
      dispatch = _useReducer2[1];

  var setFormState = (0, _react.useCallback)(function (state) {
    dispatch({
      type: FormAction.SET_FORM,
      payload: {
        state: _objectSpread({}, getState(state)),
        value: '',
        id: ''
      }
    });
  }, []);
  var onTouchHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_TOUCH,
      payload: {
        id: event.target.id,
        value: ''
      }
    });
  }, []);
  var onChangeHandler = (0, _react.useCallback)(function (event) {
    dispatch({
      type: FormAction.INPUT_CHANGE,
      payload: {
        id: event.target.id,
        value: event.target.value
      }
    });
  }, []);
  return {
    formState: formState,
    onChangeHandler: onChangeHandler,
    onTouchHandler: onTouchHandler,
    setFormState: setFormState
  };
}

var _default = useForm;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mb3JtLmhvb2sudHMiXSwibmFtZXMiOlsiRm9ybUFjdGlvbiIsImdldElucHV0IiwiaW5pdGlhbFZhbHVlIiwib3B0aW9ucyIsInBhcnNlZE9wdGlvbnMiLCJpc1ZhbGlkIiwiaXNUb3VjaGVkIiwidmFsaWRhdG9ycyIsImNvbm5lY3RlZEZpZWxkcyIsImNvbm5lY3RGaWVsZHMiLCJrZXlzIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicHVzaCIsInZhbHVlIiwiaGFuZGxlQ29ubmVjdGVkRmllbGRzIiwic3RhdGUiLCJ0YXJnZXRJZCIsIm5ld0lucHV0U3RhdGUiLCJpbnB1dHMiLCJjb25uZWN0ZWRGaWVsZElkIiwiZXJyIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwiZm9ybVJlZHVjZXIiLCJhY3Rpb24iLCJwbCIsInBheWxvYWQiLCJ0eXBlIiwiSU5QVVRfQ0hBTkdFIiwibmV3U3RhdGUiLCJpZCIsIklOUFVUX1RPVUNIIiwiU0VUX0ZPUk0iLCJnZXRTdGF0ZSIsImluaXRpYWxTdGF0ZSIsImxlbmd0aCIsInVzZUZvcm0iLCJmb3JtU3RhdGUiLCJkaXNwYXRjaCIsInNldEZvcm1TdGF0ZSIsIm9uVG91Y2hIYW5kbGVyIiwiZXZlbnQiLCJ0YXJnZXQiLCJvbkNoYW5nZUhhbmRsZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7Ozs7OztJQVNLQSxVOztXQUFBQSxVO0FBQUFBLEVBQUFBLFU7QUFBQUEsRUFBQUEsVTtBQUFBQSxFQUFBQSxVO0dBQUFBLFUsS0FBQUEsVTs7QUFvR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQyxRQUFULENBQ0hDLFlBREcsRUFFSEMsT0FGRyxFQUdjO0FBQ2pCLE1BQU1DLGFBQStDLEdBQUc7QUFDcERDLElBQUFBLE9BQU8sRUFBRSxLQUQyQztBQUVwREMsSUFBQUEsU0FBUyxFQUFFLEtBRnlD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QUQsQ0FBUjtBQUNILEdBRnNFLEVBRXBFLEVBRm9FLENBQXZFO0FBSUEsTUFBTWlDLGVBQWdFLEdBQUcsd0JBQVksVUFBQ0YsS0FBRCxFQUFXO0FBQzVGSCxJQUFBQSxRQUFRLENBQUM7QUFDTFgsTUFBQUEsSUFBSSxFQUFFakMsVUFBVSxDQUFDa0MsWUFEWjtBQUVMRixNQUFBQSxPQUFPLEVBQUU7QUFDTEksUUFBQUEsRUFBRSxFQUFFVyxLQUFLLENBQUNDLE1BQU4sQ0FBYVosRUFEWjtBQUVMcEIsUUFBQUEsS0FBSyxFQUFFK0IsS0FBSyxDQUFDQyxNQUFOLENBQWFoQztBQUZmO0FBRkosS0FBRCxDQUFSO0FBT0gsR0FSd0UsRUFRdEUsRUFSc0UsQ0FBekU7QUFVQSxTQUFPO0FBQUUyQixJQUFBQSxTQUFTLEVBQVRBLFNBQUY7QUFBYU0sSUFBQUEsZUFBZSxFQUFmQSxlQUFiO0FBQThCSCxJQUFBQSxjQUFjLEVBQWRBLGNBQTlCO0FBQThDRCxJQUFBQSxZQUFZLEVBQVpBO0FBQTlDLEdBQVA7QUFDSDs7ZUFFY0gsTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZUNhbGxiYWNrLCBSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge1xuICAgIFZhbGlkYXRvcixcbiAgICBWYWxpZGF0aW9uVHlwZSxcbiAgICBDdXN0b21WYWxpZGF0aW9uUnVsZSxcbiAgICBnZXRWYWxpZGF0b3IsXG4gICAgdmFsaWRhdGUsXG4gICAgdmFsaWRhdGVTdGF0ZVxufSBmcm9tICcuL2Zvcm0udmFsaWRhdGlvbic7XG5cbmVudW0gRm9ybUFjdGlvbiB7XG4gICAgSU5QVVRfQ0hBTkdFID0gJ0lOUFVUX0NIQU5HRScsXG4gICAgSU5QVVRfVE9VQ0ggPSAnSU5QVVRfVE9VQ0gnLFxuICAgIFNFVF9GT1JNID0gJ1NFVF9GT1JNJ1xufVxuXG5pbnRlcmZhY2UgRm9ybVBheWxvYWQgZXh0ZW5kcyBQaWNrPEZvcm1FbnRyeVN0YXRlPGFueT4sICd2YWx1ZSc+IHtcbiAgICByZWFkb25seSBpZDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHN0YXRlPzogRm9ybVN0YXRlPGFueT47XG59XG5cbnR5cGUgRm9ybUVsZW1lbnRDb25zdHJhaW50ID0gSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQgfCBIVE1MU2VsZWN0RWxlbWVudCB8IEhUTUxPcHRpb25FbGVtZW50O1xuXG50eXBlIFJlZHVjZXJBY3Rpb24gPSB7IHR5cGU6IEZvcm1BY3Rpb247IHBheWxvYWQ6IEZvcm1QYXlsb2FkIH07XG5cbnR5cGUgR2V0SW5wdXRPcHRpb25zPFQgZXh0ZW5kcyBGb3JtVmFsdWVUeXBlLCBTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludCA9IGFueT4gPSB7XG4gICAgW2tleTogc3RyaW5nXTogVCB8IG51bWJlciB8IGJvb2xlYW4gfCBDdXN0b21WYWxpZGF0aW9uUnVsZTxULCBTPiB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuICAgIG1pbkxlbmd0aD86IG51bWJlcjtcbiAgICBtYXhMZW5ndGg/OiBudW1iZXI7XG4gICAgbWluVmFsdWU/OiBudW1iZXI7XG4gICAgbWF4VmFsdWU/OiBudW1iZXI7XG4gICAgbWluVXBwZXJjYXNlQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtYXhVcHBlcmNhc2VDaGFyYWN0ZXJzPzogbnVtYmVyO1xuICAgIG1pbk51bWVyaWNhbFN5bWJvbHM/OiBudW1iZXI7XG4gICAgbWF4TnVtZXJpY2FsU3ltYm9scz86IG51bWJlcjtcbiAgICBpc1JlcXVpcmVkPzogYm9vbGVhbjtcbiAgICBpc1ZhbGlkPzogYm9vbGVhbjtcbiAgICBpc1RvdWNoZWQ/OiBib29sZWFuO1xuICAgIGN1c3RvbVJ1bGU/OiBDdXN0b21WYWxpZGF0aW9uUnVsZTxULCBTPjtcbiAgICBjb25uZWN0RmllbGRzPzogc3RyaW5nW107XG59O1xuXG4vKiBUaGlzIGlzIHRoZSBiYXNlIGZvciBhbnkgaW5wdXQgZW50cnkgaW4gYSAnZm9ybVN0YXRlJy4gSW4gb3RoZXIgd29yZHNcbiAgIGFsbCBpbnB1dCBlbnRyaWVzIHdpbGwgaGF2ZSB0aGVzZSBwcm9wZXJ0aWVzIGF2YWlsYWJsZS4gKi9cbnR5cGUgRm9ybUVudHJ5U3RhdGU8VCBleHRlbmRzIEZvcm1WYWx1ZVR5cGU+ID0ge1xuICAgIHZhbHVlOiBUO1xuICAgIGlzVmFsaWQ6IGJvb2xlYW47XG4gICAgaXNUb3VjaGVkOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHZhbGlkYXRvcnM6IFZhbGlkYXRvcltdO1xuICAgIHJlYWRvbmx5IGNvbm5lY3RlZEZpZWxkczogc3RyaW5nW107XG59O1xuXG4vKiBUaGUgdHlwZSBvZiBvYmplY3QgcmV0dXJuZWQgYnkgdXNlRm9ybSB3aGVuIGluaXRpYWxpemVkLiAqL1xuZXhwb3J0IHR5cGUgVXNlRm9ybTxTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4gPSB7XG4gICAgLyoqXG4gICAgICogZm9ybVN0YXRlJyB3aWxsIGFsd2F5cyBoYXZlIHByb3BlcnRpZXMgJ2lucHV0cycgYW5kICdpc1ZhbGlkJ1xuICAgICAqIGF2YWlsYWJsZSB3aGlsZSB0aGUgJ2lucHV0cycgcHJvcGVydHksIGlmIG5vbi1lbXB0eSwgd2lsbFxuICAgICAqIGhhdmUga2V5cyB0aGF0IHlpZWxkcyBhbiBvYmplY3Qgb2YgdHlwZSBGb3JtRW50cnlTdGF0ZVxuICAgICAqL1xuICAgIGZvcm1TdGF0ZTogRm9ybVN0YXRlPFM+O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0b3VjaCBldmVudHMuIENhbiBiZSB1c2VkIHdpdGggcHJvcCAnb25CbHVyJywgZm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBcXDxpbnB1dCBvbkJsdXI9e29uVG91Y2hIYW5kbGVyfSAvXFw+XG4gICAgICpcbiAgICAgKi9cbiAgICBvblRvdWNoSGFuZGxlcjogUmVhY3QuRm9jdXNFdmVudEhhbmRsZXI8Rm9ybUVsZW1lbnRDb25zdHJhaW50PjtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgY2hhbmdlIGV2ZW50cy4gQ2FuIGJlIHVzZWQgd2l0aCBwcm9wICdvbkNoYW5nZScsIGZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogXFw8aW5wdXQgb25DaGFuZ2U9e29uQ2hhbmdlSGFuZGxlcn0gL1xcPlxuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2VIYW5kbGVyOiBSZWFjdC5DaGFuZ2VFdmVudEhhbmRsZXI8Rm9ybUVsZW1lbnRDb25zdHJhaW50PjtcblxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZSBleGlzdGluZyBpbnB1dHMgYnkgc2V0dGluZyBuZXcgb25lczpcbiAgICAgKlxuICAgICAqIHNldEZvcm1TdGF0ZSh7XG4gICAgICogICAgIC4uLm5ld0lucHV0c1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBPciBhZGQgdG8gY3VycmVudCBpbnB1dHM6XG4gICAgICpcbiAgICAgKiBzZXRGb3JtU3RhdGUoe1xuICAgICAqICAgICAuLi5mb3JtU3RhdGUuaW5wdXRzLFxuICAgICAqICAgICAuLi5uZXdJbnB1dHNcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIE9iamVjdCB3aXRoIHRoZSBuZXcgRm9ybVN0YXRlXG4gICAgICovXG4gICAgc2V0Rm9ybVN0YXRlOiAoc3RhdGU6IEZvcm1TdGF0ZTxTPiB8IElucHV0czxTPikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCB0eXBlIElucHV0czxUIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4gPSB7IFtLIGluIGtleW9mIFRdOiBGb3JtRW50cnlTdGF0ZTxUW0tdPiB9O1xuXG4vLyBTdXBwb3J0ZWQgaW5wdXQgdmFsZXMuIENhbiBiZSBleHRlbmRlZCBpZiBuZWVkIGJlLlxuZXhwb3J0IHR5cGUgRm9ybVZhbHVlVHlwZSA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBGaWxlO1xuXG4vKiBQcm9wZXJ0eSBuYW1lcyBhbmQgdHlwZXMgb2YgaW5wdXRzLCBmb3IgZXhhbXBsZTpcbiAgIHsgcGFzc3dvcmQ6IHN0cmluZzsgYWdlOiBudW1iZXI7IGlzSGFwcHk6IGJvb2xlYW47IH0gKi9cbmV4cG9ydCB0eXBlIEZvcm1FbnRyeUNvbnN0cmFpbnQgPSB7IFtrZXk6IHN0cmluZ106IEZvcm1WYWx1ZVR5cGUgfTtcblxuZXhwb3J0IHR5cGUgRm9ybVN0YXRlPFQgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50PiA9IHtcbiAgICBpbnB1dHM6IElucHV0czxUPjtcbiAgICBpc1ZhbGlkOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IG9mIHR5cGUgRm9ybUVudHJ5U3RhdGUgYnkganVzdCBkZWZpbmluZyB0aGUgaW5wdXQgdHlwZSwgaW5pdGlhbCB2YWx1ZSBhbmQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIC0gaW5pdGlhbCB2YWx1ZSBvZiB0aGUgaW5wdXQgZW50cnkuXG4gKiBAcGFyYW0gb3B0aW9ucyAgICAgIC0gKG9wdGlvbmFsKSBvcHRpb25zIGZvciBpbml0aWFsIGlucHV0IHN0YXRlIGFuZCB2YWxpZGF0aW9uXG4gKiBAcmV0dXJucyBPYmplY3Qgb2YgdHlwZSBGb3JtRW50cnlTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5wdXQ8VCBleHRlbmRzIEZvcm1WYWx1ZVR5cGUsIFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50ID0gYW55PihcbiAgICBpbml0aWFsVmFsdWU6IFQsXG4gICAgb3B0aW9ucz86IEdldElucHV0T3B0aW9uczxULCBTPlxuKTogRm9ybUVudHJ5U3RhdGU8VD4ge1xuICAgIGNvbnN0IHBhcnNlZE9wdGlvbnM6IE9taXQ8Rm9ybUVudHJ5U3RhdGU8VD4sICd2YWx1ZSc+ID0ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgaXNUb3VjaGVkOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdG9yczogW10sXG4gICAgICAgIGNvbm5lY3RlZEZpZWxkczogb3B0aW9ucz8uY29ubmVjdEZpZWxkcyB8fCBbXVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICAgIHBhcnNlZE9wdGlvbnMuaXNUb3VjaGVkID0gISFvcHRpb25zLmlzVG91Y2hlZDtcbiAgICAgICAgcGFyc2VkT3B0aW9ucy5pc1ZhbGlkID0gISFvcHRpb25zLmlzVmFsaWQ7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIVsnaXNWYWxpZCcsICdpc1RvdWNoZWQnLCAnY29ubmVjdGVkRmllbGRzJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMudmFsaWRhdG9ycy5wdXNoKGdldFZhbGlkYXRvcihrZXkgYXMgVmFsaWRhdGlvblR5cGUsIG9wdGlvbnNba2V5XSBhcyBUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXJzZWRPcHRpb25zLFxuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlXG4gICAgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgYWxsIGNvbm5lY3RlZCBmaWVsZHMgdGllZCB0byBhIGNlcnRhaW4gaW5wdXQuIFRoaXMgaXMgdXNlZnVsIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbjpcbiAqXG4gKiBJZiB3ZSBoYXZlIGlucHV0IEEgYW5kIGlucHV0IEIgYW5kIGlucHV0IEIgaXMgZGVwZW5kZW50IHVwb24gaW5wdXQgQS4gVGhlbiB3ZSdkIGxpa2UgdG8gYmUgYWJsZSB0b1xuICogcnVuIHRoZSB2YWxpZGF0aW9uIGZvciBpbnB1dCBCIGVhY2ggdGltZSB0aGUgdmFsdWUgb2YgaW5wdXQgQSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAgIC0gY3VycmVudCBGb3JtU3RhdGUgd2hlcmUgdGhlIGNvbm5lY3RlZCBpbnB1dHMgY2FuIGJlIGZvdW5kXG4gKiBAcGFyYW0gdGFyZ2V0SWQgLSBJZCBvZiB0aGUgb3duaW5nIGlucHV0IChpbnB1dCBBIGluIHRoZSBleGFtcGxlIGFib3ZlKVxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggZW50cnkga2V5cyBhbmQgdGhlaXIgdXBkYXRlZCBvYmplY3Qgb2YgdHlwZSBGb3JtRW50cnlTdGF0ZVxuICovXG5jb25zdCBoYW5kbGVDb25uZWN0ZWRGaWVsZHMgPSAoc3RhdGU6IEZvcm1TdGF0ZTxhbnk+LCB0YXJnZXRJZDogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBGb3JtRW50cnlTdGF0ZTxhbnk+IH0gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld0lucHV0U3RhdGUgPSB7IC4uLnN0YXRlLmlucHV0cyB9O1xuICAgICAgICAvLyBmaW5kIGNvbm5lY3RlZCBmaWVsZHMgZnJvbSB0aGUgdGFyZ2V0SWRcbiAgICAgICAgbmV3SW5wdXRTdGF0ZVt0YXJnZXRJZF0uY29ubmVjdGVkRmllbGRzLmZvckVhY2goKGNvbm5lY3RlZEZpZWxkSWQpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb25uZWN0ZWQgZmllbGQgZXhpc3RzXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0lucHV0U3RhdGVbY29ubmVjdGVkRmllbGRJZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlbiB2YWxpZGF0ZSBpdCBnaXZlbiB0aGUgc3BlY2lmaWVkIHN0YXRlXG4gICAgICAgICAgICAgICAgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXSxcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZDogdmFsaWRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnB1dFN0YXRlW2Nvbm5lY3RlZEZpZWxkSWRdLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5wdXRTdGF0ZVtjb25uZWN0ZWRGaWVsZElkXS52YWxpZGF0b3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3SW5wdXRTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHJldHVybiBzdGF0ZS5pbnB1dHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgY2hhbmdlcyB0byBGb3JtU3RhdGUgZ2l2ZW4gYW4gYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCBhIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHN0YXRlIE9iamVjdCB3aXRoIGN1cnJlbnQgRm9ybVN0YXRlXG4gKiBAcGFyYW0gYWN0aW9uIEZvcm1BY3Rpb24gYW5kIEZvcm1QYXlsb2FkIHRvIGhhbmRsZVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHVwZGF0ZWQgRm9ybVN0YXRlXG4gKi9cbmZ1bmN0aW9uIGZvcm1SZWR1Y2VyPFMgZXh0ZW5kcyBGb3JtU3RhdGU8YW55Pj4oc3RhdGU6IFMsIGFjdGlvbjogUmVkdWNlckFjdGlvbik6IFMge1xuICAgIGNvbnN0IHBsID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIEZvcm1BY3Rpb24uSU5QVVRfQ0hBTkdFOlxuICAgICAgICAgICAgLy8gY29weSB0aGUgY3VycmVudCBzdGF0ZSwgdXBkYXRlIHRoZSBlbnRyeSB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZCBJZCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZTogUyA9IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICBbcGwuaWRdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbnB1dHNbcGwuaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBsLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZDogdmFsaWRhdGUocGwudmFsdWUsIHN0YXRlLmlucHV0c1twbC5pZF0udmFsaWRhdG9ycywgc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY29weSB0aGUgaW5wdXRzIGFuZCB2YWxpZGF0ZSBjb25uZWN0ZWQgZmllbGRzIGdpdmVuIHRoZSBub3cgdXBkYXRlZCBzdGF0ZS5cbiAgICAgICAgICAgIG5ld1N0YXRlLmlucHV0cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5pbnB1dHMsXG4gICAgICAgICAgICAgICAgLi4uaGFuZGxlQ29ubmVjdGVkRmllbGRzKG5ld1N0YXRlLCBwbC5pZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIHVwZGF0ZWQgRm9ybVN0YXRlXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5pbnB1dHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkYXRlU3RhdGUobmV3U3RhdGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIEZvcm1BY3Rpb24uSU5QVVRfVE9VQ0g6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbnB1dHMsXG4gICAgICAgICAgICAgICAgICAgIFtwbC5pZF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmlucHV0c1twbC5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgRm9ybUFjdGlvbi5TRVRfRk9STTpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGwuc3RhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uKHBsLnN0YXRlIGFzIFMpIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlPFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50Pihpbml0aWFsU3RhdGU6IEZvcm1TdGF0ZTxTPiB8IElucHV0czxTPik6IEZvcm1TdGF0ZTxTPiB7XG4gICAgbGV0IHN0YXRlOiBGb3JtU3RhdGU8Uz47XG4gICAgaWYgKFxuICAgICAgICBPYmplY3Qua2V5cyhpbml0aWFsU3RhdGUpLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICB0eXBlb2YgaW5pdGlhbFN0YXRlLmlucHV0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIGluaXRpYWxTdGF0ZS5pc1ZhbGlkICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgICBzdGF0ZSA9IHsgLi4uKGluaXRpYWxTdGF0ZSBhcyBGb3JtU3RhdGU8Uz4pIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBpbnB1dHM6IHsgLi4uKGluaXRpYWxTdGF0ZSBhcyBJbnB1dHM8Uz4pIH0sXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBzdGF0ZS5pc1ZhbGlkID0gdmFsaWRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gdXNlRm9ybTxTIGV4dGVuZHMgRm9ybUVudHJ5Q29uc3RyYWludD4oaW5pdGlhbFN0YXRlOiBGb3JtU3RhdGU8Uz4pOiBVc2VGb3JtPFM+O1xuXG5mdW5jdGlvbiB1c2VGb3JtPFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50Pihpbml0aWFsU3RhdGU6IElucHV0czxTPik6IFVzZUZvcm08Uz47XG5cbi8qKlxuICogUmVhY3QgaG9vayBmb3IgbWFuYWdpbmcgdGhlIHN0YXRlIG9mIGEgZm9ybSBhbmQgaXRzIGFzc29jaWF0ZWQgaW5wdXRzLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgLSBPYmplY3Qgd2l0aCBpbml0aWFsIEZvcm1TdGF0ZSBvciBpbml0aWFsIElucHV0c1xuXG4gKiBAcmV0dXJucyBPYmplY3Qgb2YgVXNlRm9ybSB0eXBlIHdpdGggc3BlY2lmaWVkIHByb3BlcnRpZXMgYW5kIHR5cGVzLlxuICovXG5mdW5jdGlvbiB1c2VGb3JtPFMgZXh0ZW5kcyBGb3JtRW50cnlDb25zdHJhaW50Pihpbml0aWFsU3RhdGU6IEZvcm1TdGF0ZTxTPiB8IElucHV0czxTPik6IFVzZUZvcm08Uz4ge1xuICAgIGNvbnN0IFtmb3JtU3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXI8UmVkdWNlcjxGb3JtU3RhdGU8Uz4sIFJlZHVjZXJBY3Rpb24+Pihmb3JtUmVkdWNlciwge1xuICAgICAgICAuLi5nZXRTdGF0ZShpbml0aWFsU3RhdGUpXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZXRGb3JtU3RhdGUgPSB1c2VDYWxsYmFjaygoc3RhdGU6IEZvcm1TdGF0ZTxTPiB8IElucHV0czxTPik6IHZvaWQgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IEZvcm1BY3Rpb24uU0VUX0ZPUk0sIHBheWxvYWQ6IHsgc3RhdGU6IHsgLi4uZ2V0U3RhdGUoc3RhdGUpIH0sIHZhbHVlOiAnJywgaWQ6ICcnIH0gfSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgb25Ub3VjaEhhbmRsZXI6IFJlYWN0LkZvY3VzRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD4gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiBGb3JtQWN0aW9uLklOUFVUX1RPVUNILCBwYXlsb2FkOiB7IGlkOiBldmVudC50YXJnZXQuaWQsIHZhbHVlOiAnJyB9IH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uQ2hhbmdlSGFuZGxlcjogUmVhY3QuQ2hhbmdlRXZlbnRIYW5kbGVyPEZvcm1FbGVtZW50Q29uc3RyYWludD4gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogRm9ybUFjdGlvbi5JTlBVVF9DSEFOR0UsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LnRhcmdldC5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IGZvcm1TdGF0ZSwgb25DaGFuZ2VIYW5kbGVyLCBvblRvdWNoSGFuZGxlciwgc2V0Rm9ybVN0YXRlIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUZvcm07XG4iXX0=